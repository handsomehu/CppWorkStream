Uninitialized objects of built-in type defined inside a function body have
undefined value. Objects of class type that we do not explicitly initialize have
a value that is defined by the class.


::global_int   use global indicator to override local variable.


A reference is not an object. Instead, a reference is just another name for an
already existing object.

Because references are not objects, they don’t have
addresses. Hence, we may not define a pointer to a reference.

Uninitialized pointers are a common source of run-time errors, so do initialize them, even as nullptr

The type void* is a special pointer type that can hold the address of any object. Like
any other pointer, a void* pointer holds an address, but the type of the object at
that address is unknown

int *&r = p // p is a int* pointer
The easiest way to understand the type of r is to read the definition right to left. The
symbol closest to the name of the variable (in this case the & in &r) is the one that
has the most immediate effect on the variable’s type. Thus, we know that r is a
reference. The rest of the declarator determines the type to which r refers. The next
symbol, * in this case, says that the type r refers to is a pointer type. Finally, the
base type of the declaration says that r is a reference to a pointer to an int.



Like a reference to const, a pointer to const says nothing about whether the
object to which the pointer points is const


It may be helpful to think of pointers and references to const as pointers or
references “that think they point or refer to const.”



Generally, it is a good idea to use constexpr for variables that you intend
to use as constant expressions.


typedef char* pstring;  //pstring is a pointer to char*(easy to remember)
dobule *p1,*p2; //usual use of pointer, pointer time of p1 and p2



decltype(f()) sum = x; // sum has whatever type f returns
Here, the compiler does not call f, but it uses the type that such a call would return
as the type for sum. That is, the compiler gives sum the same type as the type that
would be returned if we were to call f.



Remember that decltype((variable)) (note, double parentheses) is always
a reference type, but decltype(variable) is a reference type only if variable
is a reference.



#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
};
#endif
The first time Sales_data.h is included, the #ifndef test will succeed. The
preprocessor will process the lines following #ifndef up to the #endif.


Ordinarily, C++ programs should use the cname versions of headers and
not the name .h versions. That way names from the standard library are
consistently found in the std namespace. Using the .h headers puts the
burden on the programmer to remember which library names are inherited
from C and which are unique to C++.

We can define vectors to hold objects of most any type. Because references are
not objects (§ 2.3.1, p. 50), we cannot have a vector of references

The body of a range for must not change the size of the sequence over
which it is iterating.


Programmers coming to C++ from C or Java might be surprised that we used
!= rather than < in our for loops such as the one above and in the one on
page 94. C++ programmers use != as a matter of habit. They do so for the
same reason that they use iterators rather than subscripts: This coding style
applies equally well to various kinds of containers provided by the library.
As we’ve seen, only a few library types, vector and string being among
them, have the subscript operator. Similarly, all of the library containers have
iterators that define the == and != operators. Most of those iterators do not
have the < operator. By routinely using iterators and !=, we don’t have to
worry about the precise type of container we’re processing.

(*it).empty()
For reasons we’ll cover in § 4.1.2 (p. 136), the parentheses in (*it).empty() are
necessary. The parentheses say to apply the dereference operator to it and to apply
the dot operator (§ 1.5.2, p. 23) to the result of dereferencing it. Without
parentheses, the dot operator would apply to it, not to the resulting object:

To simplify expressions such as this one, the language defines the arrow operator
(the -> operator). The arrow operator combines dereference and member access into
a single operation. That is, it->mem is a synonym for (* it).mem.

Some compilers allow array assignment as a compiler extension. It is
usually a good idea to avoid using nonstandard features. Programs that use
such features, will not work with a different compiler.
int *ptrs[10]; // ptrs is an array of ten pointers to int
int &refs[10] = /* ? */; // error: no arrays of references
int (*Parray)[10] = &arr; // Parray points to an array of ten ints
int (&arrRef)[10] = arr; // arrRef refers to an array of ten ints
By default, type modifiers bind right to left. Reading the definition of ptrs from right
to left (§ 2.3.3, p. 58) is easy: We see that we’re defining an array of size 10, named
ptrs, that holds pointers to int.
Reading the definition of Parray from right to left isn’t as helpful. Because the
array dimension follows the name being declared, it can be easier to read array
declarations from the inside out rather than from right to left. Reading from the inside
out makes it much easier to understand the type of Parray. We start by observing
that the parentheses around *Parray mean that Parray is a pointer. Looking right,
we see that Parray points to an array of size 10. Looking left, we see that the
elements in that array are ints. Thus, Parray is a pointer to an array of ten ints.
Similarly, (&arrRef) says that arrRef is a reference. The type to which it refers is
an array of size 10. That array holds elements of type int.


int *(&arry)[10] = ptrs; // arry is a reference to an array of ten pointers
Reading this declaration from the inside out, we see that arry is a reference. Looking
right, we see that the object to which arry refers is an array of size 10. Looking left,
we see that the element type is pointer to int. Thus, arry is a reference to an array
of ten pointers.


int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia); // pointer one past the last element in ia
begin returns a pointer to the first, and end returns a pointer one past the last
element in the given array: These functions are defined in the iterator header.



This loop does not write to the elements, yet we still define the control variable of the
outer loop as a reference. We do so in order to avoid the normal array to pointer
conversion (§ 3.5.3, p. 117). Had we neglected the reference and written these loops
as:
for (auto row : ia)
for (auto col : row)
our program would not compile. As before, the first for iterates through ia, whose
elements are arrays of size 4. Because row is not a reference, when the compiler
initializes row it will convert each array element (like any other object of array type)
to a pointer to that array’s first element. As a result, in this loop the type of row is
int*. The inner for loop is illegal. Despite our intentions, that loop attempts to
iterate over an int*.



Note
The parentheses in this declaration are essential:
Click here to view code image
int *ip[4]; // array of pointers to int
int (*ip)[4]; // pointer to an array of four ints


!!!!!!
Roughly speaking, when we use an object as an rvalue,
we use the object’s value (its contents). When we use an object as an lvalue, we use
the object’s identity (its location in memory).



Because assignment has lower precedence than the relational operators,
parentheses are usually needed around assignments in conditions.


Advice: Use Postfix Operators only When Necessary
Means use ++I as mucha s possible unless you need the other one

void* p = &d; // ok: address of any nonconst object can be stored in a void*
// ok: converts void* back to the original pointer type
double *dp = static_cast<double*>(p);


Arrays have two special properties that affect how we define and use functions that
operate on arrays: We cannot copy an array (§ 3.5.1, p. 114), and when we use an
array it is (usually) converted to a pointer (§ 3.5.3, p. 117). Because we cannot copy
an array, we cannot pass an array by value. Because arrays are converted to pointers,
when we pass an array to a function, we are actually passing a pointer to the array’s
first element.


Whether a function call is an lvalue (§ 4.1.1, p. 135) depends on the return type of
the function. Calls to functions that return references are lvalues; other return types
yield rvalues. A call to a function that returns a reference can be used in the same
C++ Primer, Fifth Edition
ways as any other lvalue. In particular, we can assign to the result of a function that
returns a reference to nonconst:

Because we cannot copy an array, a function cannot return an array. However, a
function can return a pointer or a reference to an array

As a concrete example, the following declares func without using a type alias:
int (*func(int i))[10];
To understand this declaration, it can be helpful to think about it as follows:
• func(int) says that we can call func with an int argument.
• (*func(int)) says we can dereference the result of that call.
• (*func(int))[10] says that dereferencing the result of a call to func yields
an array of size ten.
• int (*func(int))[10] says the element type in that array is int.



auto func(int i) -> int(*)[10];
Because the return type comes after the parameter list, it is easier to see that func
returns a pointer and that that pointer points to an array of ten ints.


It is an error for two functions to differ only in terms of their return types. If the
parameter lists of two functions match but the return types differ, then the second
declaration is an error:


As we saw in § 6.2.3 (p. 212), top-level const (§ 2.4.3, p. 63) has no effect on the
objects that can be passed to the function. A parameter that has a top-level const is
indistinguishable from one without a top-level const:
Click here to view code image

Record lookup(Phone);
Record lookup(const Phone); // redeclares Record lookup(Phone)


A function specified as inline (usually) is expanded “in line” at each call. If
shorterString were defined as inline, then this call
Click here to view code image
cout << shorterString(s1, s2) << endl;
(probably) would be expanded during compilation into something like
C++ Primer, Fifth Edition
Click here to view code image
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
The run-time overhead of making shorterString a function is thus removed.

A constexpr function is permitted to return a value that is not a constant:
Click here to view code image
// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
The scale function

As a result, inline and constexpr
functions normally are defined in headers.



A function pointer is just that—a pointer that denotes a function rather than an
object. Like any other pointer, a function pointer points to a particular type. A
function’s type is determined by its return type and the types of its parameters. The
function’s name is not part of its type. For example:
Click here to view code image
// compares lengths of two strings
bool lengthCompare(const string &, const string &);
has type bool(const string&, const string&). To declare a pointer that can
point at this function, we declare a pointer in place of the function name:
Click here to view code image
// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &); // uninitialized


When we pass a function as an argument, we can do so directly. It will be
automatically converted to a pointer:
Click here to view code image
// automatically converts the function lengthCompare to a pointer to function
useBigger(s1, s2, lengthCompare);


The only tricky part in declaring getFcn is to remember that when we apply
decltype to a function, it returns a function type, not a pointer to function type. We
must add a * to indicate that we are returning a pointer, not a function.

It sometimes (but not very often) happens that a class has a data member that we
want to be able to modify, even inside a const member function. We indicate such
members by including the mutable keyword in their declaration.

A const member function that returns *this as a reference should have a
return type that is a reference to const.

I am on page 362 of cpp primer
