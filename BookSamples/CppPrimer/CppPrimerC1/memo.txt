Uninitialized objects of built-in type defined inside a function body have
undefined value. Objects of class type that we do not explicitly initialize have
a value that is defined by the class.


::global_int   use global indicator to override local variable.


A reference is not an object. Instead, a reference is just another name for an
already existing object.

Because references are not objects, they don’t have
addresses. Hence, we may not define a pointer to a reference.

Uninitialized pointers are a common source of run-time errors, so do initialize them, even as nullptr

The type void* is a special pointer type that can hold the address of any object. Like
any other pointer, a void* pointer holds an address, but the type of the object at
that address is unknown

int *&r = p // p is a int* pointer
The easiest way to understand the type of r is to read the definition right to left. The
symbol closest to the name of the variable (in this case the & in &r) is the one that
has the most immediate effect on the variable’s type. Thus, we know that r is a
reference. The rest of the declarator determines the type to which r refers. The next
symbol, * in this case, says that the type r refers to is a pointer type. Finally, the
base type of the declaration says that r is a reference to a pointer to an int.



Like a reference to const, a pointer to const says nothing about whether the
object to which the pointer points is const


It may be helpful to think of pointers and references to const as pointers or
references “that think they point or refer to const.”



Generally, it is a good idea to use constexpr for variables that you intend
to use as constant expressions.


typedef char* pstring;  //pstring is a pointer to char*(easy to remember)
dobule *p1,*p2; //usual use of pointer, pointer time of p1 and p2



decltype(f()) sum = x; // sum has whatever type f returns
Here, the compiler does not call f, but it uses the type that such a call would return
as the type for sum. That is, the compiler gives sum the same type as the type that
would be returned if we were to call f.



Remember that decltype((variable)) (note, double parentheses) is always
a reference type, but decltype(variable) is a reference type only if variable
is a reference.



#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
};
#endif
The first time Sales_data.h is included, the #ifndef test will succeed. The
preprocessor will process the lines following #ifndef up to the #endif.


Ordinarily, C++ programs should use the cname versions of headers and
not the name .h versions. That way names from the standard library are
consistently found in the std namespace. Using the .h headers puts the
burden on the programmer to remember which library names are inherited
from C and which are unique to C++.

We can define vectors to hold objects of most any type. Because references are
not objects (§ 2.3.1, p. 50), we cannot have a vector of references

The body of a range for must not change the size of the sequence over
which it is iterating.


Programmers coming to C++ from C or Java might be surprised that we used
!= rather than < in our for loops such as the one above and in the one on
page 94. C++ programmers use != as a matter of habit. They do so for the
same reason that they use iterators rather than subscripts: This coding style
applies equally well to various kinds of containers provided by the library.
As we’ve seen, only a few library types, vector and string being among
them, have the subscript operator. Similarly, all of the library containers have
iterators that define the == and != operators. Most of those iterators do not
have the < operator. By routinely using iterators and !=, we don’t have to
worry about the precise type of container we’re processing.

(*it).empty()
For reasons we’ll cover in § 4.1.2 (p. 136), the parentheses in (*it).empty() are
necessary. The parentheses say to apply the dereference operator to it and to apply
the dot operator (§ 1.5.2, p. 23) to the result of dereferencing it. Without
parentheses, the dot operator would apply to it, not to the resulting object:

To simplify expressions such as this one, the language defines the arrow operator
(the -> operator). The arrow operator combines dereference and member access into
a single operation. That is, it->mem is a synonym for (* it).mem.

Some compilers allow array assignment as a compiler extension. It is
usually a good idea to avoid using nonstandard features. Programs that use
such features, will not work with a different compiler.
int *ptrs[10]; // ptrs is an array of ten pointers to int
int &refs[10] = /* ? */; // error: no arrays of references
int (*Parray)[10] = &arr; // Parray points to an array of ten ints
int (&arrRef)[10] = arr; // arrRef refers to an array of ten ints
By default, type modifiers bind right to left. Reading the definition of ptrs from right
to left (§ 2.3.3, p. 58) is easy: We see that we’re defining an array of size 10, named
ptrs, that holds pointers to int.
Reading the definition of Parray from right to left isn’t as helpful. Because the
array dimension follows the name being declared, it can be easier to read array
declarations from the inside out rather than from right to left. Reading from the inside
out makes it much easier to understand the type of Parray. We start by observing
that the parentheses around *Parray mean that Parray is a pointer. Looking right,
we see that Parray points to an array of size 10. Looking left, we see that the
elements in that array are ints. Thus, Parray is a pointer to an array of ten ints.
Similarly, (&arrRef) says that arrRef is a reference. The type to which it refers is
an array of size 10. That array holds elements of type int.


int *(&arry)[10] = ptrs; // arry is a reference to an array of ten pointers
Reading this declaration from the inside out, we see that arry is a reference. Looking
right, we see that the object to which arry refers is an array of size 10. Looking left,
we see that the element type is pointer to int. Thus, arry is a reference to an array
of ten pointers.


int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia); // pointer one past the last element in ia
begin returns a pointer to the first, and end returns a pointer one past the last
element in the given array: These functions are defined in the iterator header.



This loop does not write to the elements, yet we still define the control variable of the
outer loop as a reference. We do so in order to avoid the normal array to pointer
conversion (§ 3.5.3, p. 117). Had we neglected the reference and written these loops
as:
for (auto row : ia)
for (auto col : row)
our program would not compile. As before, the first for iterates through ia, whose
elements are arrays of size 4. Because row is not a reference, when the compiler
initializes row it will convert each array element (like any other object of array type)
to a pointer to that array’s first element. As a result, in this loop the type of row is
int*. The inner for loop is illegal. Despite our intentions, that loop attempts to
iterate over an int*.



Note
The parentheses in this declaration are essential:
Click here to view code image
int *ip[4]; // array of pointers to int
int (*ip)[4]; // pointer to an array of four ints


!!!!!!
Roughly speaking, when we use an object as an rvalue,
we use the object’s value (its contents). When we use an object as an lvalue, we use
the object’s identity (its location in memory).



Because assignment has lower precedence than the relational operators,
parentheses are usually needed around assignments in conditions.


Advice: Use Postfix Operators only When Necessary
Means use ++I as mucha s possible unless you need the other one

void* p = &d; // ok: address of any nonconst object can be stored in a void*
// ok: converts void* back to the original pointer type
double *dp = static_cast<double*>(p);


Arrays have two special properties that affect how we define and use functions that
operate on arrays: We cannot copy an array (§ 3.5.1, p. 114), and when we use an
array it is (usually) converted to a pointer (§ 3.5.3, p. 117). Because we cannot copy
an array, we cannot pass an array by value. Because arrays are converted to pointers,
when we pass an array to a function, we are actually passing a pointer to the array’s
first element.


Whether a function call is an lvalue (§ 4.1.1, p. 135) depends on the return type of
the function. Calls to functions that return references are lvalues; other return types
yield rvalues. A call to a function that returns a reference can be used in the same
C++ Primer, Fifth Edition
ways as any other lvalue. In particular, we can assign to the result of a function that
returns a reference to nonconst:

Because we cannot copy an array, a function cannot return an array. However, a
function can return a pointer or a reference to an array

As a concrete example, the following declares func without using a type alias:
int (*func(int i))[10];
To understand this declaration, it can be helpful to think about it as follows:
• func(int) says that we can call func with an int argument.
• (*func(int)) says we can dereference the result of that call.
• (*func(int))[10] says that dereferencing the result of a call to func yields
an array of size ten.
• int (*func(int))[10] says the element type in that array is int.



auto func(int i) -> int(*)[10];
Because the return type comes after the parameter list, it is easier to see that func
returns a pointer and that that pointer points to an array of ten ints.


It is an error for two functions to differ only in terms of their return types. If the
parameter lists of two functions match but the return types differ, then the second
declaration is an error:


As we saw in § 6.2.3 (p. 212), top-level const (§ 2.4.3, p. 63) has no effect on the
objects that can be passed to the function. A parameter that has a top-level const is
indistinguishable from one without a top-level const:
Click here to view code image

Record lookup(Phone);
Record lookup(const Phone); // redeclares Record lookup(Phone)


A function specified as inline (usually) is expanded “in line” at each call. If
shorterString were defined as inline, then this call
Click here to view code image
cout << shorterString(s1, s2) << endl;
(probably) would be expanded during compilation into something like
C++ Primer, Fifth Edition
Click here to view code image
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
The run-time overhead of making shorterString a function is thus removed.

A constexpr function is permitted to return a value that is not a constant:
Click here to view code image
// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
The scale function

As a result, inline and constexpr
functions normally are defined in headers.



A function pointer is just that—a pointer that denotes a function rather than an
object. Like any other pointer, a function pointer points to a particular type. A
function’s type is determined by its return type and the types of its parameters. The
function’s name is not part of its type. For example:
Click here to view code image
// compares lengths of two strings
bool lengthCompare(const string &, const string &);
has type bool(const string&, const string&). To declare a pointer that can
point at this function, we declare a pointer in place of the function name:
Click here to view code image
// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &); // uninitialized


When we pass a function as an argument, we can do so directly. It will be
automatically converted to a pointer:
Click here to view code image
// automatically converts the function lengthCompare to a pointer to function
useBigger(s1, s2, lengthCompare);


The only tricky part in declaring getFcn is to remember that when we apply
decltype to a function, it returns a function type, not a pointer to function type. We
must add a * to indicate that we are returning a pointer, not a function.

It sometimes (but not very often) happens that a class has a data member that we
want to be able to modify, even inside a const member function. We indicate such
members by including the mutable keyword in their declaration.

A const member function that returns *this as a reference should have a
return type that is a reference to const.

It is important to understand that friendship is not transitive. That is, if class
Window_mgr has its own friends, those friends have no special access to Screen.

It is important to understand that a friend declaration affects access but is not a
declaration in an ordinary sense.

// bad practice: don't hide names that are needed from surrounding scopes
void Screen::dummy_fcn(pos height) {
cursor = width * ::height;// which height? the global one
}
Note
Even though the outer object is hidden, it is still possible to access that
object by using the scope operator.

We must use the constructor initializer list to provide values for members that
are const, reference, or of a class type that does not have a default
constructor.


It is a good idea to write constructor initializers in the same order as the
members are declared. Moreover, when possible, avoid using members to
initialize other members.

The default constructor is used automatically whenever an object is default or value
initialized. Default initialization happens:
    • When we define nonstatic variables (§ 2.2.1, p. 43) or arrays (§3.5.1, p.
    114) at block scope without initializers
    • When a class that itself has members of class type uses the synthesized default
    constructor (§ 7.1.4, p. 262)
    • When members of class type are not explicitly initialized in a constructor
    initializer list (§ 7.1.4, p. 265)
    Value initialization happens
    • During array initialization when we provide fewer initializers than the size of the
    C++ Primer, Fifth Edition
    array (§ 3.5.1, p. 114)
    • When we define a local static object without an initializer (§ 6.1.1, p. 205)
    • When we explicitly request value initialization by writing an expressions of the
    form T() where T is the name of a type (The vector constructor that takes a
    single argument to specify the vector’s size (§ 3.3.1, p. 98) uses an argument
    of this kind to value initialize its element initializer.)

In practice, it is almost always right to provide a default constructor if other
constructors are being defined.

It is a common mistake among programmers new to C++ to try to declare
an object initialized with the default constructor as follows:
Click here to view code image
Sales_data obj(); // oops! declares a function, not an object
Sales_data obj2; // ok: obj2 is an object, not a function


string null_book = "9-999-99999-9";
// constructs a temporary Sales_data object
// with units_sold and revenue equal to 0 and bookNo equal to null_book
item.combine(null_book); //implict convert null_book from string to Sales_data

We can prevent the use of a constructor in a context that requires an implicit
conversion by declaring the constructor as explicit:

The explicit keyword is meaningful only on constructors that can be called with
a single argument. Constructors that require more arguments are not used to perform
an implicit conversion, so there is no need to designate such constructors as
explicit.

An aggregate class gives users direct access to its members and has special
initialization syntax. A class is an aggregate if
• All of its data members are public
• It does not define any constructors
• It has no in-class initializers (§ 2.6.1, p. 73)
• It has no base classes or virtual functions, which are class-related features
that we’ll cover in Chapter 15
For example, the following class is an aggregate:
struct Data {
int ival;
string s;
};

Similarly, static member functions are not bound to any object; they do not have
a this pointer. As a result, static member functions may not be declared as
const, and we may not refer to this in the body of a static member. This
restriction applies both to explicit uses of this and to implicit uses of this by calling
a nonstatic member.

// define and initialize a static class member
double Account::interestRate = initRate();
This statement defines the object named interestRate that is a static member
of class Account and has type double. Once the class name is seen, the remainder
of the definition is in the scope of the class. As a result, we can use initRate
without qualification as the initializer for rate. Note also that even though initRate
is private, we can use this function to initialize interestRate. The definition of
interestRate, like any other member definition, has access to the private
members of the class.

class Bar {
public:
// ...
private:
    static Bar mem1; // ok: static member can have incomplete type
    Bar *mem2; // ok: pointer member can have incomplete type
    Bar mem3; // error: data members must have complete type
}


As we saw in § 7.1.3 (p. 261), we cannot copy or assign objects of the IO types


If you’re not sure which container to use, write your code so that it uses only
operations common to both vectors and lists: Use iterators, not
subscripts, and avoid random access to elements. That way it will be easy to
use either a vector or a list as necessary.


It is worth noting that although we cannot copy or assign objects of built-in array
types (§ 3.5.1, p. 114), there is no such restriction on array:
Click here to view code image
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // error: no copy or assignment for built-in arrays
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits; // ok: so long as array types match
As


array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0}; // elements all have value 0
a1 = a2; // replaces elements in a1
a2 = {0}; // error: cannot assign to an array from a braced list
Because the size of the right-hand operand might differ from the size of the left-hand
operand, the array type does not support assign and it does not allow assignment
from a braced list of values.

Key Concept: Container Elements Are Copies
When we use an object to initialize a container, or insert an object into a
container, a copy of that object’s value is placed in the container, not the
object itself. Just as when we pass an object to a nonreference parameter (§
6.2.1, p. 209), there is no relationship between the element in the container
and the object from which that value originated. Subsequent changes to the
element in the container have no effect on the original object, and vice versa.


When we call a push or insert member, we pass objects of the element type and
those objects are copied into the container. When we call an emplace member, we
pass arguments to a constructor for the element type. The emplace members use
those arguments to construct an element directly in space managed by the container.

The resize operation takes an optional element-value argument that it uses to
initialize any elements that are added to the container. If this argument is absent,
added elements are value initialized (§ 3.3.1, p. 98). If the container holds elements of
a class type and resize adds elements, we must supply an initializer or the element
type must have a default constructor.


When we add or remove elements in a vector or string, or add elements or
remove any but the first element in a deque, the iterator returned by end is always
invalidated. Thus, loops that add or remove elements should always call end rather
than use a stored copy. Partly for this reason, C++ standard libraries are usually
implemented so that calling end() is a very fast operation.

Algorithms that write to a destination iterator assume the destination is large
enough to hold the number of elements being written.

For the same reasons as we usually initialize variables, it is also a good idea
to initialize dynamically allocated objects.

int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i; // error: i is not a pointer
delete pi1; // undefined: pi1 refers to a local
delete pd; // ok
delete pd2; // undefined: the memory pointed to by pd2 was already freed
delete pi2; // ok: it is always ok to delete a null pointer


It is dangerous to use a built-in pointer to access an object owned by a
smart pointer, because we may not know when that object is destroyed.

Use get only to pass access to the pointer to code that you know will not
delete the pointer. In particular, never use get to initialize or assign to
another smart pointer.

Caution: Smart Pointer Pitfalls
Smart pointers can provide safety and convenience for handling dynamically
allocated memory only when they are used properly. To use smart pointers
correctly, we must adhere to a set of conventions:
• Don’t use the same built-in pointer value to initialize (or reset) more than
one smart pointer.
• Don’t delete the pointer returned from get().
• Don’t use get() to initialize or reset another smart pointer.
• If you use a pointer returned by get(), remember that the pointer will
become invalid when the last corresponding smart pointer goes away.
• If you use a smart pointer to manage a resource other than memory
allocated by new, remember to pass a deleter

Because the allocated memory does not have an array type, we cannot call begin
or end (§ 3.5.3, p. 118) on a dynamic array. These functions use the array dimension
(which is part of an array’s type) to return pointers to the first and one past the last
elements, respectively. For the same reasons, we also cannot use a range for to
process the elements in a (so-called) dynamic array.


char arr[0]; // error: cannot define a zero-length array
char *cp = new char[0]; // ok: but cp can't be dereferenced
When we use new to allocate an array of size zero, new returns a valid, nonzero
pointer. That pointer is guaranteed to be distinct from any other pointer returned by
new. This pointer acts as the off-the-end pointer (§ 3.5.3, p. 119) for a zero-element
array. We can use this pointer in ways that we use an off-the-end iterator. The
pointer can be compared as in the loop above. We can add zero to (or subtract zero
from) such a pointer and can subtract the pointer from itself, yielding zero. The
pointer cannot be dereferenced—after all, it points to no element.


The library provides a version of unique_ptr that can manage arrays allocated by
new. To use a unique_ptr to manage a dynamic array, we must include a pair of
empty brackets after the object type:
// up points to an array of ten uninitialized ints
unique_ptr<int[]> up(new int[10]);
up.release(); // automatically uses delete[] to destroy its pointer


Unlike unique_ptr, shared_ptrs provide no direct support for managing a
dynamic array. If we want to use a shared_ptr to manage a dynamic array, we
must provide our own deleter:
// to use a shared_ptr we must supply a deleter
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
sp.reset(); // uses the lambda we supplied that uses delete[] to free the array

The fact that shared_ptr does not directly support managing arrays affects how we
access the elements in the array:
// shared_ptrs don't have subscript operator and don't support pointer arithmetic
for (size_t i = 0; i != 10; ++i)
*(sp.get() + i) = i; // use get to get a built-in pointer

More importantly, classes that do not have default constructors cannot be
dynamically allocated as an array.

The copy constructor is used implicitly
in several circumstances. Hence, the copy constructor usually should not be
explicit

string dots(10, '.'); // direct initialization
string s(dots); // direct initialization
string s2 = dots; // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, '9'); // copy initialization

Assignment operators ordinarily should return a reference to their left-hand operand.

Because it takes no parameters, it cannot be overloaded. There is always only one
destructor for a given class.

The implicit destruction of a member of built-in pointer type does not
delete the object to which that pointer points.

If a class needs a destructor, it almost surely also needs the copy-assignment
operator and a copy constructor.

This example gives rise to a second rule of thumb: If a class needs a copy
constructor, it almost surely needs a copy-assignment operator. And vice versa—if the
class needs an assignment operator, it almost surely needs a copy constructor as well.
Nevertheless, needing either the copy constructor or the copy-assignment operator
does not (necessarily) indicate the need for a destructor.


Under the new standard, we can prevent copies by defining the copy constructor and
copy-assignment operator as deleted functions. A deleted function is one that is
declared but may not be used in any other way. We indicate that we want to define a
function as deleted by following its parameter list with = delete:
Click here

It is not possible to define an object or delete a pointer to a dynamically
allocated object of a type with a deleted destructor.

• The synthesized destructor is defined as deleted if the class has a member
whose own destructor is deleted or is inaccessible (e.g., private).
• The synthesized copy constructor is defined as deleted if the class has a
member whose own copy constructor is deleted or inaccessible. It is also deleted
if the class has a member with a deleted or inaccessible destructor.
• The synthesized copy-assignment operator is defined as deleted if a member
has a deleted or inaccessible copy-assignment operator, or if the class has a
const or reference member.
• The synthesized default constructor is defined as deleted if the class has a
member with a deleted or inaccessible destructor; or has a reference member
that does not have an in-class initializer (§ 2.6.1, p. 73); or has a const
member whose type does not explicitly define a default constructor and that
member does not have an in-class initializer.

Prior to the new standard, classes prevented copies by declaring their copy constructor
and copy-assignment operator as private

Classes that want to prevent copying should define their copy constructor and
copy-assignment operators using = delete rather than making those
members private.

Key Concept: Assignment Operators
There are two points to keep in mind when you write an assignment
operator:
• Assignment operators must work correctly if an object is assigned to itself.
• Most assignment operators share work with the destructor and copy
constructor.
A good pattern to use when you write an assignment operator is to first copy
the right-hand operand into a local temporary. After the copy is done, it is
safe to destroy the existing members of the left-hand operand. Once the lefthand
operand is destroyed, copy the data from the temporary into the
members of the left-hand operand

It is crucially important for assignment operators to work correctly, even
when an object is assigned to itself. A good way to do so is to copy the
right-hand operand before destroying the left-hand operand.

An rvalue reference is a reference that must be bound to an
rvalue. An rvalue reference is obtained by using && rather than &. As we’ll see, rvalue
references have the important property that they may be bound only to an object that
is about to be destroyed. As a result, we are free to “move” resources from an rvalue
reference to another object.

int i = 42;
int &r = i; // ok: r refers to i
int &&rr = i; // error: cannot bind an rvalue reference to an lvalue
int &r2 = i * 42; // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication

Functions that return lvalue references, along with the assignment, subscript,
dereference, and prefix increment/decrement operators, are all examples of
expressions that return lvalues. We can bind an lvalue reference to the result of any of
these expressions.
Functions that return a nonreference type, along with the arithmetic, relational,
bitwise, and postfix increment/decrement operators, all yield rvalues. We cannot bind
an lvalue reference to these expressions, but we can bind either an lvalue reference to
const or an rvalue reference to such expressions.

Because rvalue references can only be bound to temporaries, we know that
• The referred-to object is about to be destroyed
• There can be no other users of that object

Rvalue references refer to objects that are about to be destroyed. Hence, we
can “steal” state from an object bound to an rvalue reference.


int &&rr1 = 42; // ok: literals are rvalues
int &&rr2 = rr1; // error: the expression rr1 is an lvalue!
int &&rr3 = std::move(rr1); // ok


We can destroy a moved-from object and can assign a new value to it, but
we cannot use the value of a moved-from object.

StrVec::StrVec(StrVec &&s) noexcept // move won't throw any
exceptions
// member initializers take over the resources in s
: elements(s.elements), first_free(s.first_free),
cap(s.cap)
{
// leave s in a state in which it is safe to run the destructor
s.elements = s.first_free = s.cap = nullptr;
}

Move constructors and move assignment operators that cannot throw
exceptions should be marked as noexcept.

StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
// direct test for self-assignment
if (this != &rhs) {
free(); // free existing elements
elements = rhs.elements; // take over resources from rhs
first_free = rhs.first_free;
cap = rhs.cap;
// leave rhs in a destructible state
rhs.elements = rhs.first_free = rhs.cap = nullptr;
}
return *this;
}

The compiler synthesizes the move constructor and move assignment only if
a class does not define any of its own copy-control members and only if all
the data members can be moved constructed and move assigned,
respectively.

Classes that define a move constructor or move-assignment operator must
also define their own copy operations. Otherwise, those members are deleted
by default.

If a class has a usable copy constructor and no move constructor, objects will
be “moved” by the copy constructor. Similarly for the copy-assignment
operator and move-assignment.

Advice: Updating the Rule of Three
All five copy-control members should be thought of as a unit: Ordinarily, if a
class defines any of these operations, it usually should define them all. As
we’ve seen, some classes must define the copy constructor, copy-assignment
operator, and destructor to work correctly (§ 13.1.4, p. 504). Such classes
typically have a resource that the copy members must copy. Ordinarily,
copying a resource entails some amount of overhead. Classes that define the
move constructor and move-assignment operator can avoid this overhead in
those circumstances where a copy isn’t necessary.

We transform an ordinary iterator to a move iterator by calling the library
make_move_iterator function. This function takes an iterator and returns a move
iterator.

Outside of class implementation code such as move constructors or
move-assignment operators, use std::move only when you are certain
that you need to do a move and that the move is guaranteed to be safe.


Overloaded functions that distinguish between moving and copying a
parameter typically have one version
that takes a const T& and one that
takes a T&&.

When an overloaded operator is a member function, this is bound to the
left-hand operand. Member operator functions have one less (explicit)
parameter than the number of operands.

Ordinarily, the comma, address-of, logical AND, and logical OR operators
should not be overloaded.

Obvious abuses of operator overloading rarely happen in practice. As an
example, no responsible programmer would define operator+ to perform
subtraction. More common, but still inadvisable, are uses that contort an
operator’s “normal” meaning to force a fit to a given type. Operators should
be used only for operations that are likely to be unambiguous to users. An
operator has an ambiguous meaning if it plausibly has more than one
interpretation.


The following guidelines can be of help in deciding whether to make an operator a
member or an ordinary nonmember function:
• The assignment (=), subscript ([]), call (()), and member access arrow (->)
operators must be defined as members.
• The compound-assignment operators ordinarily ought to be members. However,
unlike assignment, they are not required to be members.
• Operators that change the state of their object or that are closely tied to their given type—such as increment, decrement, and dereference—usually should be
members.
• Symmetric operators—those that might convert either operand, such as the
arithmetic, equality, relational, and bitwise operators—usually should be defined
as ordinary nonmember functions.

string s = "world";
string t = s + "!"; // ok: we can add a const char* to a string
string u = "hi" + s; // would be an error if + were a member of string
If operator+ were a member of the string class, the first addition would be
equivalent to s.operator+("!"). Likewise, "hi" + s would be equivalent to
"hi".operator+(s). However, the type of "hi" is const char*, and that is a
built-in type; it does not even have member functions.

Generally, output operators should print the contents of the object, with
minimal formatting. They should not print a newline.

Input and output operators that conform to the conventions of the iostream library
must be ordinary nonmember functions.

Ordinarily, we define the arithmetic and relational operators as nonmember functions
in order to allow conversions for either the left- or right-hand operand (§ 14.1, p.
555). These operators shouldn’t need to change the state of either operand, so the
parameters are ordinarily references to const.

bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
return lhs.isbn() == rhs.isbn() &&
lhs.units_sold == rhs.units_sold &&
lhs.revenue == rhs.revenue;
}
bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
return !(lhs == rhs);
}

Assignment operators can be overloaded. Assignment operators, regardless of
parameter type, must be defined as member functions.


Assignment operators must, and ordinarily compound-assignment operators
should, be defined as members. These operators should return a reference to
the left-hand operand.

The subscript operator must be a member function.

If a class has a subscript operator, it usually should define two versions: one
that returns a plain reference and the other that is a const member and
returns a reference to const.

Classes that define increment or decrement operators should define both the
prefix and postfix versions. These operators usually should be defined as
members

To be consistent with the built-in operators, the postfix operators should
return the old (unincremented or undecremented) value. That value is
returned as a value, not a reference.


class StrBlobPtr {
public:
std::string& operator*() const
{ auto p = check(curr, "dereference past end");
return (*p)[curr]; // (*p) is the vector to which this object points
}
std::string* operator->() const
{ // delegate the real work to the dereference operator
return & this->operator*();
}
// other members as before
};

The overloaded arrow operator must return either a pointer to a class type or
an object of a class type that defines its own operator arrow.

The function-call operator must be a member function. A class may define
multiple versions of the call operator, each of which must differ as to the
number or types of their parameters.

map<string, function<int(int, int)>> binops = {
{"+", add}, // function pointer
{"-", std::minus<int>()}, // library function object
{"/", div()}, // user-defined function object
{"*", [](int i, int j) { return i * j; }}, // unnamed
lambda
{"%", mod} };

A conversion operator is a special kind of member function that converts a value of
a class type to a value of some other type. A conversion function typically has the
general form
operator type() const;

where type represents a type. Conversion operators can be defined for any type
(other than void) that can be a function return type (§ 6.1, p. 204). Conversions to
an array or a function type are not permitted. Conversions to pointer types—both data
and function pointers—and to reference types are allowed.

A conversion function must be a member function, may not specify a return
type, and must have an empty parameter list. The function usually should be
const.

If the conversion operator is explicit, we can still do the conversion. However, with
one exception, we must do so explicitly through a cast.

Conversion to bool is usually intended for use in conditions. As a result,
operator bool ordinarily should be defined as explicit.


Caution: Conversions and Operators
Correctly designing the overloaded operators, conversion constructors, and
conversion functions for a class requires some care. In particular, ambiguities
are easy to generate if a class defines both conversion operators and
overloaded operators. A few rules of thumb can be helpful:
• Don’t define mutually converting classes—if class Foo has a constructor
that takes an object of class Bar, do not give Bar a conversion operator to
type Foo.
• Avoid conversions to the built-in arithmetic types. In particular, if you do
define a conversion to an arithmetic type, then
– Do not define overloaded versions of the operators that take arithmetic
types. If users need to use these operators, the conversion operation will
convert objects of your type, and then the built-in operators can be used.
– Do not define a conversion to more than one arithmetic type. Let the
standard conversions provide conversions to the other arithmetic types.
The easiest rule of all: With the exception of an explicit conversion to
bool, avoid defining conversion functions and limit nonexplicit
constructors to those that are “obviously right.”

The set of candidate functions for an operator used in an expression can
contain both nonmember and member functions.

In C++, dynamic binding happens when a virtual function is called through a
reference (or a pointer) to a base class.


Base classes ordinarily should define a virtual destructor. Virtual destructors
are needed even if they do no work.

A function that is declared as
virtual in the base class is implicitly virtual in the derived classes as well.

The base class is initialized first, and then the members of the derived class
are initialized in the order in which they are declared in the class.

It is essential to understand that each class defines its own interface.
Interactions with an object of a class-type should use the interface of that
class, even if that object is the base-class part of a derived object.
As a result, derived-class constructors may not directly initialize the
members of its base class. The constructor body of a derived constructor can
assign values to its public or protected base-class members. Although it
can assign to those members, it generally should not do so. Like any other
user of the base class, a derived class should respect the interface of its base
class by using a constructor to initialize its inherited members.

Bulk_quote bulk;
Quote *itemP = &bulk; // ok: dynamic type is Bulk_quote
Bulk_quote *bulkP = itemP; // error: can't convert base to derived

When we initialize or assign an object of a base type from an object of a
derived type, only the base-class part of the derived object is copied, moved,
or assigned. The derived part of the object is ignored.

There are three things that are important to understand about conversions
among classes related by inheritance:
• The conversion from derived to base applies only to pointer or reference types.
• There is no implicit conversion from the base-class type to the derived
type.
• Like any member, the derived-to-base conversion may be inaccessible due
to access controls. We’ll cover accessibility in §15.5 (p. 613).
Although the automatic conversion applies only to pointers and references,
most classes in an inheritance hierarchy (implicitly or explicitly) define the
copy-control members (Chapter 13). As a result, we can often copy, move, or
assign an object of derived type to a base-type object. However, copying,
moving, or assigning a derived-type object to a base-type object copies,
moves, or assigns only the members in the base-class part of the object.

It is crucial to understand that dynamic binding happens only when a virtual
function is called through a pointer or a reference.

Virtuals are resolved at run time only if the call is made through a
reference or pointer. Only in these cases is it possible for an object’s
dynamic type to differ from its static type.

When a derived class overrides a virtual function, it may, but is not required to, repeat
the virtual keyword. Once a function is declared as virtual, it remains virtual
in all the derived classes.

A function that is virtual in a base class is implicitly virtual in its
derived classes. When a derived class overrides a virtual, the parameters in
the base and derived classes must match exactly.

struct B {
virtual void f1(int) const;
virtual void f2();
void f3();
};
struct D1 : B {
void f1(int) const override; // ok: f1 matches f1 in the base
void f2(int) override; // error: B has no f2(int) function
void f3() override; // error: f3 not virtual
void f4() override; // error: B doesn't have a function named f4
}

Virtual functions that have default arguments should use the same argument
values in the base and derived classes.

If a derived virtual function that intended to call its base-class version omits
the scope operator, the call will be resolved at run time as a call to the
derived version itself, resulting in an infinite recursion.

We may not create objects of a type that is an abstract base class.

A derived class member or friend may access the protected members of the
base class only through a derived object. The derived class has no special
access to the protected members of base-class objects.

For any given point in your code, if a public member of the base class
would be accessible, then the derived-to-base conversion is also accessible,
and not otherwise.


In the absence of inheritance, we can think of a class as having two different
kinds of users: ordinary users and implementors. Ordinary users write code
that uses objects of the class type; such code can access only the public
(interface) members of the class. Implementors write the code contained in
the members and friends of the class. The members and friends of the class
can access both the public and private (implementation) sections.
Under inheritance, there is a third kind of user, namely, derived classes. A
base class makes protected those parts of its implementation that it is
willing to let its derived classes use. The protected members remain
inaccessible to ordinary user code; private members remain inaccessible to
derived classes and their friends.
Like any other class, a class that is used as a base class makes its interface
members public . A class that is used as a base class may divide its
implementation into those members that are accessible to derived classes and
those that remain accessible only to the base class and its friends. An
implementation member should be protected if it provides an operation or
data that a derived class will need to use in its own implementation.
Otherwise, implementation members should be private.

Just as friendship is not transitive (§7.3.4, p. 279), friendship is also not inherited.
Friends of the base have no special access to members of its derived classes, and
friends of a derived class have no special access to the base class:

A derived-class member with the same name as a member of the base class
hides direct use of the base-class member.

Executing delete on a pointer to base that points to a derived object has
undefined behavior if the base’s destructor is not virtual.

The fact that a base class needs a virtual destructor has an important indirect impact
on the definition of base and derived classes: If a class defines a destructor—even if
it uses = default to use the synthesized version—the compiler will not synthesize a
move operation for that class (§13.6.2, p. 537).

By default, the base-class default constructor initializes the base-class part of
a derived object. If we want copy (or move) the base-class part, we must
explicitly use the copy (or move) constructor for the base class in the
derived’s constructor initializer list.

If a constructor or destructor calls a virtual, the version that is run is the one
corresponding to the type of the constructor or destructor itself.

When we need a container that holds objects related by inheritance, we typically
define the container to hold pointers (preferably smart pointers (§12.1, p. 450)) to the
base class. As usual, the dynamic type of the object to which those pointers point
might be the base-class type or a type derived from that base:

Page 779
