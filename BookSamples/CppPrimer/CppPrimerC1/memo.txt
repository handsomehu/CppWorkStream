Uninitialized objects of built-in type defined inside a function body have
undefined value. Objects of class type that we do not explicitly initialize have
a value that is defined by the class.


::global_int   use global indicator to override local variable.


A reference is not an object. Instead, a reference is just another name for an
already existing object.

Because references are not objects, they don’t have
addresses. Hence, we may not define a pointer to a reference.

Uninitialized pointers are a common source of run-time errors, so do initialize them, even as nullptr

The type void* is a special pointer type that can hold the address of any object. Like
any other pointer, a void* pointer holds an address, but the type of the object at
that address is unknown

int *&r = p // p is a int* pointer
The easiest way to understand the type of r is to read the definition right to left. The
symbol closest to the name of the variable (in this case the & in &r) is the one that
has the most immediate effect on the variable’s type. Thus, we know that r is a
reference. The rest of the declarator determines the type to which r refers. The next
symbol, * in this case, says that the type r refers to is a pointer type. Finally, the
base type of the declaration says that r is a reference to a pointer to an int.



Like a reference to const, a pointer to const says nothing about whether the
object to which the pointer points is const


It may be helpful to think of pointers and references to const as pointers or
references “that think they point or refer to const.”



Generally, it is a good idea to use constexpr for variables that you intend
to use as constant expressions.


typedef char* pstring;  //pstring is a pointer to char*(easy to remember)
dobule *p1,*p2; //usual use of pointer, pointer time of p1 and p2



decltype(f()) sum = x; // sum has whatever type f returns
Here, the compiler does not call f, but it uses the type that such a call would return
as the type for sum. That is, the compiler gives sum the same type as the type that
would be returned if we were to call f.



Remember that decltype((variable)) (note, double parentheses) is always
a reference type, but decltype(variable) is a reference type only if variable
is a reference.



#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
};
#endif
The first time Sales_data.h is included, the #ifndef test will succeed. The
preprocessor will process the lines following #ifndef up to the #endif.


Ordinarily, C++ programs should use the cname versions of headers and
not the name .h versions. That way names from the standard library are
consistently found in the std namespace. Using the .h headers puts the
burden on the programmer to remember which library names are inherited
from C and which are unique to C++.

We can define vectors to hold objects of most any type. Because references are
not objects (§ 2.3.1, p. 50), we cannot have a vector of references

The body of a range for must not change the size of the sequence over
which it is iterating.


Programmers coming to C++ from C or Java might be surprised that we used
!= rather than < in our for loops such as the one above and in the one on
page 94. C++ programmers use != as a matter of habit. They do so for the
same reason that they use iterators rather than subscripts: This coding style
applies equally well to various kinds of containers provided by the library.
As we’ve seen, only a few library types, vector and string being among
them, have the subscript operator. Similarly, all of the library containers have
iterators that define the == and != operators. Most of those iterators do not
have the < operator. By routinely using iterators and !=, we don’t have to
worry about the precise type of container we’re processing.

(*it).empty()
For reasons we’ll cover in § 4.1.2 (p. 136), the parentheses in (*it).empty() are
necessary. The parentheses say to apply the dereference operator to it and to apply
the dot operator (§ 1.5.2, p. 23) to the result of dereferencing it. Without
parentheses, the dot operator would apply to it, not to the resulting object:

To simplify expressions such as this one, the language defines the arrow operator
(the -> operator). The arrow operator combines dereference and member access into
a single operation. That is, it->mem is a synonym for (* it).mem.

Some compilers allow array assignment as a compiler extension. It is
usually a good idea to avoid using nonstandard features. Programs that use
such features, will not work with a different compiler.
int *ptrs[10]; // ptrs is an array of ten pointers to int
int &refs[10] = /* ? */; // error: no arrays of references
int (*Parray)[10] = &arr; // Parray points to an array of ten ints
int (&arrRef)[10] = arr; // arrRef refers to an array of ten ints
By default, type modifiers bind right to left. Reading the definition of ptrs from right
to left (§ 2.3.3, p. 58) is easy: We see that we’re defining an array of size 10, named
ptrs, that holds pointers to int.
Reading the definition of Parray from right to left isn’t as helpful. Because the
array dimension follows the name being declared, it can be easier to read array
declarations from the inside out rather than from right to left. Reading from the inside
out makes it much easier to understand the type of Parray. We start by observing
that the parentheses around *Parray mean that Parray is a pointer. Looking right,
we see that Parray points to an array of size 10. Looking left, we see that the
elements in that array are ints. Thus, Parray is a pointer to an array of ten ints.
Similarly, (&arrRef) says that arrRef is a reference. The type to which it refers is
an array of size 10. That array holds elements of type int.


int *(&arry)[10] = ptrs; // arry is a reference to an array of ten pointers
Reading this declaration from the inside out, we see that arry is a reference. Looking
right, we see that the object to which arry refers is an array of size 10. Looking left,
we see that the element type is pointer to int. Thus, arry is a reference to an array
of ten pointers.


int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia); // pointer one past the last element in ia
begin returns a pointer to the first, and end returns a pointer one past the last
element in the given array: These functions are defined in the iterator header.



This loop does not write to the elements, yet we still define the control variable of the
outer loop as a reference. We do so in order to avoid the normal array to pointer
conversion (§ 3.5.3, p. 117). Had we neglected the reference and written these loops
as:
for (auto row : ia)
for (auto col : row)
our program would not compile. As before, the first for iterates through ia, whose
elements are arrays of size 4. Because row is not a reference, when the compiler
initializes row it will convert each array element (like any other object of array type)
to a pointer to that array’s first element. As a result, in this loop the type of row is
int*. The inner for loop is illegal. Despite our intentions, that loop attempts to
iterate over an int*.



Note
The parentheses in this declaration are essential:
Click here to view code image
int *ip[4]; // array of pointers to int
int (*ip)[4]; // pointer to an array of four ints


!!!!!!
Roughly speaking, when we use an object as an rvalue,
we use the object’s value (its contents). When we use an object as an lvalue, we use
the object’s identity (its location in memory).
