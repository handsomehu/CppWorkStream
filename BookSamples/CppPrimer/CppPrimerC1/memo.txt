Uninitialized objects of built-in type defined inside a function body have
undefined value. Objects of class type that we do not explicitly initialize have
a value that is defined by the class.


::global_int   use global indicator to override local variable.


A reference is not an object. Instead, a reference is just another name for an
already existing object.

Because references are not objects, they don’t have
addresses. Hence, we may not define a pointer to a reference.

Uninitialized pointers are a common source of run-time errors, so do initialize them, even as nullptr

The type void* is a special pointer type that can hold the address of any object. Like
any other pointer, a void* pointer holds an address, but the type of the object at
that address is unknown

int *&r = p // p is a int* pointer
The easiest way to understand the type of r is to read the definition right to left. The
symbol closest to the name of the variable (in this case the & in &r) is the one that
has the most immediate effect on the variable’s type. Thus, we know that r is a
reference. The rest of the declarator determines the type to which r refers. The next
symbol, * in this case, says that the type r refers to is a pointer type. Finally, the
base type of the declaration says that r is a reference to a pointer to an int.



Like a reference to const, a pointer to const says nothing about whether the
object to which the pointer points is const


It may be helpful to think of pointers and references to const as pointers or
references “that think they point or refer to const.”



Generally, it is a good idea to use constexpr for variables that you intend
to use as constant expressions.


typedef char* pstring;  //pstring is a pointer to char*(easy to remember)
dobule *p1,*p2; //usual use of pointer, pointer time of p1 and p2



decltype(f()) sum = x; // sum has whatever type f returns
Here, the compiler does not call f, but it uses the type that such a call would return
as the type for sum. That is, the compiler gives sum the same type as the type that
would be returned if we were to call f.



Remember that decltype((variable)) (note, double parentheses) is always
a reference type, but decltype(variable) is a reference type only if variable
is a reference.



#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
};
#endif
The first time Sales_data.h is included, the #ifndef test will succeed. The
preprocessor will process the lines following #ifndef up to the #endif.


Ordinarily, C++ programs should use the cname versions of headers and
not the name .h versions. That way names from the standard library are
consistently found in the std namespace. Using the .h headers puts the
burden on the programmer to remember which library names are inherited
from C and which are unique to C++.

We can define vectors to hold objects of most any type. Because references are
not objects (§ 2.3.1, p. 50), we cannot have a vector of references

The body of a range for must not change the size of the sequence over
which it is iterating.


Programmers coming to C++ from C or Java might be surprised that we used
!= rather than < in our for loops such as the one above and in the one on
page 94. C++ programmers use != as a matter of habit. They do so for the
same reason that they use iterators rather than subscripts: This coding style
applies equally well to various kinds of containers provided by the library.
As we’ve seen, only a few library types, vector and string being among
them, have the subscript operator. Similarly, all of the library containers have
iterators that define the == and != operators. Most of those iterators do not
have the < operator. By routinely using iterators and !=, we don’t have to
worry about the precise type of container we’re processing.

(*it).empty()
For reasons we’ll cover in § 4.1.2 (p. 136), the parentheses in (*it).empty() are
necessary. The parentheses say to apply the dereference operator to it and to apply
the dot operator (§ 1.5.2, p. 23) to the result of dereferencing it. Without
parentheses, the dot operator would apply to it, not to the resulting object:

To simplify expressions such as this one, the language defines the arrow operator
(the -> operator). The arrow operator combines dereference and member access into
a single operation. That is, it->mem is a synonym for (* it).mem.

Some compilers allow array assignment as a compiler extension. It is
usually a good idea to avoid using nonstandard features. Programs that use
such features, will not work with a different compiler.
int *ptrs[10]; // ptrs is an array of ten pointers to int
int &refs[10] = /* ? */; // error: no arrays of references
int (*Parray)[10] = &arr; // Parray points to an array of ten ints
int (&arrRef)[10] = arr; // arrRef refers to an array of ten ints
By default, type modifiers bind right to left. Reading the definition of ptrs from right
to left (§ 2.3.3, p. 58) is easy: We see that we’re defining an array of size 10, named
ptrs, that holds pointers to int.
Reading the definition of Parray from right to left isn’t as helpful. Because the
array dimension follows the name being declared, it can be easier to read array
declarations from the inside out rather than from right to left. Reading from the inside
out makes it much easier to understand the type of Parray. We start by observing
that the parentheses around *Parray mean that Parray is a pointer. Looking right,
we see that Parray points to an array of size 10. Looking left, we see that the
elements in that array are ints. Thus, Parray is a pointer to an array of ten ints.
Similarly, (&arrRef) says that arrRef is a reference. The type to which it refers is
an array of size 10. That array holds elements of type int.


int *(&arry)[10] = ptrs; // arry is a reference to an array of ten pointers
Reading this declaration from the inside out, we see that arry is a reference. Looking
right, we see that the object to which arry refers is an array of size 10. Looking left,
we see that the element type is pointer to int. Thus, arry is a reference to an array
of ten pointers.


int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia); // pointer one past the last element in ia
begin returns a pointer to the first, and end returns a pointer one past the last
element in the given array: These functions are defined in the iterator header.



This loop does not write to the elements, yet we still define the control variable of the
outer loop as a reference. We do so in order to avoid the normal array to pointer
conversion (§ 3.5.3, p. 117). Had we neglected the reference and written these loops
as:
for (auto row : ia)
for (auto col : row)
our program would not compile. As before, the first for iterates through ia, whose
elements are arrays of size 4. Because row is not a reference, when the compiler
initializes row it will convert each array element (like any other object of array type)
to a pointer to that array’s first element. As a result, in this loop the type of row is
int*. The inner for loop is illegal. Despite our intentions, that loop attempts to
iterate over an int*.



Note
The parentheses in this declaration are essential:
Click here to view code image
int *ip[4]; // array of pointers to int
int (*ip)[4]; // pointer to an array of four ints


!!!!!!
Roughly speaking, when we use an object as an rvalue,
we use the object’s value (its contents). When we use an object as an lvalue, we use
the object’s identity (its location in memory).



Because assignment has lower precedence than the relational operators,
parentheses are usually needed around assignments in conditions.


Advice: Use Postfix Operators only When Necessary
Means use ++I as mucha s possible unless you need the other one

void* p = &d; // ok: address of any nonconst object can be stored in a void*
// ok: converts void* back to the original pointer type
double *dp = static_cast<double*>(p);


Arrays have two special properties that affect how we define and use functions that
operate on arrays: We cannot copy an array (§ 3.5.1, p. 114), and when we use an
array it is (usually) converted to a pointer (§ 3.5.3, p. 117). Because we cannot copy
an array, we cannot pass an array by value. Because arrays are converted to pointers,
when we pass an array to a function, we are actually passing a pointer to the array’s
first element.


Whether a function call is an lvalue (§ 4.1.1, p. 135) depends on the return type of
the function. Calls to functions that return references are lvalues; other return types
yield rvalues. A call to a function that returns a reference can be used in the same
C++ Primer, Fifth Edition
ways as any other lvalue. In particular, we can assign to the result of a function that
returns a reference to nonconst:

Because we cannot copy an array, a function cannot return an array. However, a
function can return a pointer or a reference to an array

As a concrete example, the following declares func without using a type alias:
int (*func(int i))[10];
To understand this declaration, it can be helpful to think about it as follows:
• func(int) says that we can call func with an int argument.
• (*func(int)) says we can dereference the result of that call.
• (*func(int))[10] says that dereferencing the result of a call to func yields
an array of size ten.
• int (*func(int))[10] says the element type in that array is int.



auto func(int i) -> int(*)[10];
Because the return type comes after the parameter list, it is easier to see that func
returns a pointer and that that pointer points to an array of ten ints.


It is an error for two functions to differ only in terms of their return types. If the
parameter lists of two functions match but the return types differ, then the second
declaration is an error:


As we saw in § 6.2.3 (p. 212), top-level const (§ 2.4.3, p. 63) has no effect on the
objects that can be passed to the function. A parameter that has a top-level const is
indistinguishable from one without a top-level const:
Click here to view code image

Record lookup(Phone);
Record lookup(const Phone); // redeclares Record lookup(Phone)


A function specified as inline (usually) is expanded “in line” at each call. If
shorterString were defined as inline, then this call
Click here to view code image
cout << shorterString(s1, s2) << endl;
(probably) would be expanded during compilation into something like
C++ Primer, Fifth Edition
Click here to view code image
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
The run-time overhead of making shorterString a function is thus removed.

A constexpr function is permitted to return a value that is not a constant:
Click here to view code image
// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
The scale function

As a result, inline and constexpr
functions normally are defined in headers.



A function pointer is just that—a pointer that denotes a function rather than an
object. Like any other pointer, a function pointer points to a particular type. A
function’s type is determined by its return type and the types of its parameters. The
function’s name is not part of its type. For example:
Click here to view code image
// compares lengths of two strings
bool lengthCompare(const string &, const string &);
has type bool(const string&, const string&). To declare a pointer that can
point at this function, we declare a pointer in place of the function name:
Click here to view code image
// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &); // uninitialized


When we pass a function as an argument, we can do so directly. It will be
automatically converted to a pointer:
Click here to view code image
// automatically converts the function lengthCompare to a pointer to function
useBigger(s1, s2, lengthCompare);


The only tricky part in declaring getFcn is to remember that when we apply
decltype to a function, it returns a function type, not a pointer to function type. We
must add a * to indicate that we are returning a pointer, not a function.

It sometimes (but not very often) happens that a class has a data member that we
want to be able to modify, even inside a const member function. We indicate such
members by including the mutable keyword in their declaration.

A const member function that returns *this as a reference should have a
return type that is a reference to const.

It is important to understand that friendship is not transitive. That is, if class
Window_mgr has its own friends, those friends have no special access to Screen.

It is important to understand that a friend declaration affects access but is not a
declaration in an ordinary sense.

// bad practice: don't hide names that are needed from surrounding scopes
void Screen::dummy_fcn(pos height) {
cursor = width * ::height;// which height? the global one
}
Note
Even though the outer object is hidden, it is still possible to access that
object by using the scope operator.

We must use the constructor initializer list to provide values for members that
are const, reference, or of a class type that does not have a default
constructor.


It is a good idea to write constructor initializers in the same order as the
members are declared. Moreover, when possible, avoid using members to
initialize other members.

The default constructor is used automatically whenever an object is default or value
initialized. Default initialization happens:
    • When we define nonstatic variables (§ 2.2.1, p. 43) or arrays (§3.5.1, p.
    114) at block scope without initializers
    • When a class that itself has members of class type uses the synthesized default
    constructor (§ 7.1.4, p. 262)
    • When members of class type are not explicitly initialized in a constructor
    initializer list (§ 7.1.4, p. 265)
    Value initialization happens
    • During array initialization when we provide fewer initializers than the size of the
    C++ Primer, Fifth Edition
    array (§ 3.5.1, p. 114)
    • When we define a local static object without an initializer (§ 6.1.1, p. 205)
    • When we explicitly request value initialization by writing an expressions of the
    form T() where T is the name of a type (The vector constructor that takes a
    single argument to specify the vector’s size (§ 3.3.1, p. 98) uses an argument
    of this kind to value initialize its element initializer.)

In practice, it is almost always right to provide a default constructor if other
constructors are being defined.

It is a common mistake among programmers new to C++ to try to declare
an object initialized with the default constructor as follows:
Click here to view code image
Sales_data obj(); // oops! declares a function, not an object
Sales_data obj2; // ok: obj2 is an object, not a function


string null_book = "9-999-99999-9";
// constructs a temporary Sales_data object
// with units_sold and revenue equal to 0 and bookNo equal to null_book
item.combine(null_book); //implict convert null_book from string to Sales_data

We can prevent the use of a constructor in a context that requires an implicit
conversion by declaring the constructor as explicit:

The explicit keyword is meaningful only on constructors that can be called with
a single argument. Constructors that require more arguments are not used to perform
an implicit conversion, so there is no need to designate such constructors as
explicit.

An aggregate class gives users direct access to its members and has special
initialization syntax. A class is an aggregate if
• All of its data members are public
• It does not define any constructors
• It has no in-class initializers (§ 2.6.1, p. 73)
• It has no base classes or virtual functions, which are class-related features
that we’ll cover in Chapter 15
For example, the following class is an aggregate:
struct Data {
int ival;
string s;
};

Similarly, static member functions are not bound to any object; they do not have
a this pointer. As a result, static member functions may not be declared as
const, and we may not refer to this in the body of a static member. This
restriction applies both to explicit uses of this and to implicit uses of this by calling
a nonstatic member.

// define and initialize a static class member
double Account::interestRate = initRate();
This statement defines the object named interestRate that is a static member
of class Account and has type double. Once the class name is seen, the remainder
of the definition is in the scope of the class. As a result, we can use initRate
without qualification as the initializer for rate. Note also that even though initRate
is private, we can use this function to initialize interestRate. The definition of
interestRate, like any other member definition, has access to the private
members of the class.

class Bar {
public:
// ...
private:
    static Bar mem1; // ok: static member can have incomplete type
    Bar *mem2; // ok: pointer member can have incomplete type
    Bar mem3; // error: data members must have complete type
}


As we saw in § 7.1.3 (p. 261), we cannot copy or assign objects of the IO types


If you’re not sure which container to use, write your code so that it uses only
operations common to both vectors and lists: Use iterators, not
subscripts, and avoid random access to elements. That way it will be easy to
use either a vector or a list as necessary.


It is worth noting that although we cannot copy or assign objects of built-in array
types (§ 3.5.1, p. 114), there is no such restriction on array:
Click here to view code image
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // error: no copy or assignment for built-in arrays
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits; // ok: so long as array types match
As


array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0}; // elements all have value 0
a1 = a2; // replaces elements in a1
a2 = {0}; // error: cannot assign to an array from a braced list
Because the size of the right-hand operand might differ from the size of the left-hand
operand, the array type does not support assign and it does not allow assignment
from a braced list of values.

Key Concept: Container Elements Are Copies
When we use an object to initialize a container, or insert an object into a
container, a copy of that object’s value is placed in the container, not the
object itself. Just as when we pass an object to a nonreference parameter (§
6.2.1, p. 209), there is no relationship between the element in the container
and the object from which that value originated. Subsequent changes to the
element in the container have no effect on the original object, and vice versa.


When we call a push or insert member, we pass objects of the element type and
those objects are copied into the container. When we call an emplace member, we
pass arguments to a constructor for the element type. The emplace members use
those arguments to construct an element directly in space managed by the container.

The resize operation takes an optional element-value argument that it uses to
initialize any elements that are added to the container. If this argument is absent,
added elements are value initialized (§ 3.3.1, p. 98). If the container holds elements of
a class type and resize adds elements, we must supply an initializer or the element
type must have a default constructor.


When we add or remove elements in a vector or string, or add elements or
remove any but the first element in a deque, the iterator returned by end is always
invalidated. Thus, loops that add or remove elements should always call end rather
than use a stored copy. Partly for this reason, C++ standard libraries are usually
implemented so that calling end() is a very fast operation.

Algorithms that write to a destination iterator assume the destination is large
enough to hold the number of elements being written.

For the same reasons as we usually initialize variables, it is also a good idea
to initialize dynamically allocated objects.

int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i; // error: i is not a pointer
delete pi1; // undefined: pi1 refers to a local
delete pd; // ok
delete pd2; // undefined: the memory pointed to by pd2 was already freed
delete pi2; // ok: it is always ok to delete a null pointer


It is dangerous to use a built-in pointer to access an object owned by a
smart pointer, because we may not know when that object is destroyed.

Use get only to pass access to the pointer to code that you know will not
delete the pointer. In particular, never use get to initialize or assign to
another smart pointer.

Caution: Smart Pointer Pitfalls
Smart pointers can provide safety and convenience for handling dynamically
allocated memory only when they are used properly. To use smart pointers
correctly, we must adhere to a set of conventions:
• Don’t use the same built-in pointer value to initialize (or reset) more than
one smart pointer.
• Don’t delete the pointer returned from get().
• Don’t use get() to initialize or reset another smart pointer.
• If you use a pointer returned by get(), remember that the pointer will
become invalid when the last corresponding smart pointer goes away.
• If you use a smart pointer to manage a resource other than memory
allocated by new, remember to pass a deleter

Because the allocated memory does not have an array type, we cannot call begin
or end (§ 3.5.3, p. 118) on a dynamic array. These functions use the array dimension
(which is part of an array’s type) to return pointers to the first and one past the last
elements, respectively. For the same reasons, we also cannot use a range for to
process the elements in a (so-called) dynamic array.


char arr[0]; // error: cannot define a zero-length array
char *cp = new char[0]; // ok: but cp can't be dereferenced
When we use new to allocate an array of size zero, new returns a valid, nonzero
pointer. That pointer is guaranteed to be distinct from any other pointer returned by
new. This pointer acts as the off-the-end pointer (§ 3.5.3, p. 119) for a zero-element
array. We can use this pointer in ways that we use an off-the-end iterator. The
pointer can be compared as in the loop above. We can add zero to (or subtract zero
from) such a pointer and can subtract the pointer from itself, yielding zero. The
pointer cannot be dereferenced—after all, it points to no element.


The library provides a version of unique_ptr that can manage arrays allocated by
new. To use a unique_ptr to manage a dynamic array, we must include a pair of
empty brackets after the object type:
// up points to an array of ten uninitialized ints
unique_ptr<int[]> up(new int[10]);
up.release(); // automatically uses delete[] to destroy its pointer


Unlike unique_ptr, shared_ptrs provide no direct support for managing a
dynamic array. If we want to use a shared_ptr to manage a dynamic array, we
must provide our own deleter:
// to use a shared_ptr we must supply a deleter
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
sp.reset(); // uses the lambda we supplied that uses delete[] to free the array

The fact that shared_ptr does not directly support managing arrays affects how we
access the elements in the array:
// shared_ptrs don't have subscript operator and don't support pointer arithmetic
for (size_t i = 0; i != 10; ++i)
*(sp.get() + i) = i; // use get to get a built-in pointer

More importantly, classes that do not have default constructors cannot be
dynamically allocated as an array.

Page 605
