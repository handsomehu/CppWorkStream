A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in
extremely rare circumstances.

constexpr: meaning roughly ‘‘to be evaluated at compile time’’ (§10.4).

The size of an array must be a constant expression

a
reference cannot be made to refer to a different object after its initialization


Such a statement of what is assumed
to be true for a class is called a class invariant, or simply an invariant.

Also, it is not possible to change
the meaning of an operator for built-in types, so you can’t redefine + to subtract ints  ? cannot redefine plus?

The curious =0 syntax says the function is pure virtual; that is, some class derived
from Container must define the function  --- no baisc difenition , must override


Shape∗ read_shape(istream& is) // read shape descriptions from input stream is
{
// ... read shape header from is and find its Kind k ...
switch (k) {
case Kind::circle:
// read circle data {Point,int} into p and r
return new Circle{p,r};
case Kind::triangle:
// read triangle data {Point,Point,Point} into p1, p2, and p3
return new Triangle{p1,p2,p3};
case Kind::smiley:
// read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1 ,e2, and m
Smiley∗ ps = new Smiley{p,r};
ps−>add_eye(e1);
ps−>add_eye(e2);
ps−>set_mouth(m);
return ps;
}
}


void user()
{
std::vector<Shape∗> v;
while (cin)
v.push_back(read_shape(cin));
draw_all(v); //call draw() for each element
rotate_all(v,45); //call rotate(45) for each element
for (auto p : v) delete p; // remember to delete elements
}

// new within create and delete after use.

For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some
sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy,
and for abstract types it almost never is.


A move operation is applied when an rvalue reference is used as an initializer or as the righthand
side of an assignment.

Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer
to a base, we simply don’t know what members the derived class has (§3.2.2), so we can’t know
how to copy them. So, the best thing to do is usually to delete the default copy and move operations,
that is, to eliminate the default definitions of those two operations:

A pointer can be implicitly converted to a bool (§10.5.2.5). A non-null pointer converts to true;
pointers with the value nullptr convert to false.

The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned
instead of an int to gain one more bit to represent positive integers is almost never a good idea.
Attempts to ensure that some values are positive by declaring variables unsigned will typically be
defeated by the implicit conversion rules

A literal starting with zero followed by x or X (0x or 0X) is a hexadecimal (base 16) number. A
literal starting with zero but not followed by x or X is an octal (base 8) number.


The suffix U can be used to write explicitly unsigned literals. Similarly, the suffix L can be used
to write explicitly long literals. For example, 3 is an int, 3U is an unsigned int, and 3L is a long int.
Combinations of suffixes are allowed.

Choosing the right precision for a problem where the choice matters requires significant understanding
of floating-point computation. If you don’t hav e that understanding, get advice, take the
time to learn, or use double and hope for the best.


Suffixes not starting with _ are reserved for the standard library.

Sizes of C++ objects are expressed in terms of multiples of the size of a char, so by definition
the size of a char is 1. The size of an object or type can be obtained using the sizeof operator
(§10.3).



There must always be exactly one definition for each name in a C++ program (for the effects of
#include, see §15.2.3). However, there can be many declarations.
extern int error_number;
extern int error_number; // OK: redeclaration

Nonlocal names starting with an underscore are reserved for special facilities in the implementation
and the run-time environment, so such names should not be used in application programs. Similarly,
names starting with a double underscore (__) or an underscore followed by an uppercase letter
(e.g., _Foo) are reserved (

Try to maintain a consistent naming style. For example, capitalize names of user-defined types
and start names of non-type entities with a lowercase letter (for example, Shape and current_token).
Also, use all capitals for macros (if you must use macros (§12.6); for example, HACK) and never for
non-macros (not even for non-macro constants). Use underscores to separate words in an identifier;
number_of_elements is more readable than numberOfElements.

int x = 97;
void f3()
{
int x = x; // per verse: initialize x with its own (uninitialized) value
// it works, very funny. x hide global x after it's init.
}


Local variables and objects created on the free store (sometimes called dynamic objects or heap
objects; §11.2) are not initialized by default unless they are of user-defined types with a default
constructor (§17.3.3). For example:
void f()
{
int x; // x does not have a well-defined value
char buf[1024]; // buf[i] does not have a well-defined value
int∗ p {newint}; //*p does not have a well-defined value
char∗ q {new char[1024]}; // q[i] does not have a well-defined value
string s; // s=="" because of string’s default constructor
vector<char> v; // v=={} because of vector’s default constructor
string∗ ps {new string}; // *ps is "" because of string’s default constructor
// ...
}
x is defined within a funciton f(), is that the reason x is in heap rather than stack?




So, a classical lvalue is something that has identity and cannot be moved (because we could examine
it after a move), and a classical rvalue is anything that we are allowed to move from. The other
alternatives are prvalue (‘‘pure rvalue’’), glvalue (‘‘generalized lvalue’’), and xvalue (‘‘x’’ for ‘‘extraordinary’’
or ‘‘expert only’’; the suggestions for the meaning of this ‘‘x’’ hav e been quite imaginative).


Static objects can cause serious
problems in a multi-threaded program because they are shared among all threads and
typically require locking to avoid data races (§5.3.1, §42.3).


Thread-local objects; that is, objects declared thread_local (§42.2.8): such objects are created
when their thread is and destroyed when their thread is.

typedef void(∗PtoF)(int); // equivalent to ‘‘using PtoF = void(*)(int);’’   WTF

We cannot apply type specifiers, such as unsigned, to an alias. For example:
using Char = char;
using Uchar = unsigned Char; // error
using Uchar = unsigned char; // OK


Consequently, the smallest object that can be independently allocated and
pointed to using a built-in pointer type is a char


The ∗, meaning ‘‘pointer to,’’ is used as a suffix for a type name. Unfortunately, pointers to
arrays and pointers to functions need a more complicated notation:
int∗pi; //pointer to int
char∗∗ ppc; //pointer to pointer to char
int∗ ap[15]; // array of 15 pointers to ints
int (∗fp)(char∗); // pointer to function taking a char* argument; returns an int
int∗ f(char∗); //function taking a char* argument; returns a pointer to int

since BS said it is a suffix to type name, than I shall use this way consistantly.


You can read
void∗ as ‘‘pointer to an object of unknown type.’’

A pointer to any type of object can be assigned to a variable of type void∗, but a pointer to function
(§12.5) or a pointer to member (§20.6) cannot.In addition, a void∗ can be assigned to another
void∗, void∗s can be compared for equality and inequality, and a void∗ can be explicitly converted to
another type.


There is no built-in copy operation for arrays. You cannot initialize one array with another (not
ev en of exactly the same type), and there is no array assignment:


R"∗∗∗("quoted string containing the usual terminator ("))")∗∗∗"
// "quoted string containing the usual terminator ("))"


It usually surprises people to find that a[j]==j[a]. For example, 3["Texas"]=="Texas"[3]=='a'.

Subtraction of pointers is defined only when both pointers point to elements of the same array

When subtracting a pointer p
from another pointer q, q−p, the result is the number of array elements in the sequence [p:q)

// q is not include


To
declare a pointer itself, rather than the object pointed to, to be a constant, we use the declarator
operator ∗const instead of plain ∗.


The declarator operator that makes a pointer constant is ∗const. There is no const∗ declarator operator,
so a const appearing before the ∗ is taken to be part of the base type.

Thus, we cannot have a pointer to a reference. Furthermore, we cannot define
an array of references. In that sense, a reference is not an object.


// you can init a const reference from a rvalue(indirectly).
double& dr = 1; // error : lvalue needed
const double& cdr {1}; // OK
The interpretation of this last initialization might be:
double temp = double{1}; // first create a temporar y with the right value
const double& cdr {temp}; // then use the temporar y as the initializer for cdr
A



using rr_i = int&&;
using lr_i = int&;
using rr_rr_i = rr_i&&; // ‘‘int && &&’’ is an int&&
using lr_rr_i = rr_i&; // ‘‘int && &’’ is an int&
using rr_lr_i = lr_i&&; // ‘‘int & &&’’ is an int&
using lr_lr_i = lr_i&; // ‘‘int & &’’ is an int&
In other words, lvalue reference always wins.This makes sense: nothing we can do with types can
change the fact that an lvalue reference refers to an lvalue. This is sometimes known as reference
collapse.

It is not possible to (re)define an operator for a pair of built-in types, such as pointers


It is usually best to order members for readability and sort them by size only if there is a
demonstrated need to optimize.


template<typename T>
void mycopy(T∗ to, const T∗ from, int count)
{
if (is_pod<T>::value)
memcpy(to,from,count∗sizeof(T));
else
for (int i=0; i!=count; ++i)
to[i]=from[i];
}



struct PPN { // R6000 Physical Page Number
unsigned int PFN : 22; // Page Frame Number
int : 3; // unused
unsigned int CCA : 3; // Cache Coherency Algorithm
bool nonreachable : 1;
bool dirty : 1;
bool valid : 1;
bool global : 1;
};
This example also illustrates the other main use of fields: to name parts of an externally imposed
layout. A field must be of an integral or enumeration type (§6.2.1). It is not possible to take the
address of a field. Apart from that, however, it can be used exactly like other variables. Note that a
bool field really can be represented by a single bit.

enum E1 { a, b };
enum class E2 { a, b };
void f(E1 x, E2 y)
{
if (x) // OK
// ...
if (y) // error : no conversion to bool
// ...
if (y==E2::a) // OK
// ...
}


switch (val) { // beware
case 1:
cout << "case 1\n";
case 2:
cout << "case 2\n";
default:
cout << "default: case not found\n";
}
Invoked with val==1, the output will greatly surprise the uninitiated:
case 1
case 2
default: case not found

constexpr string ss = s; // error : s is not a constant expression
constexpr int yy = y; // error : sqr t(x) is not a constant expression
The reasons for the errors are that string is not a literal type (§10.4.3) and sqrt() is not a constexpr
function (§12.1.6).



When working with constexpr, the key thing to remember is that constexpr is all about values.
There are no objects that can change values or side effects here: constexpr provides a miniature
compile-time functional programming language.

Note that a pointer to function or a pointer to member cannot be implicitly
converted to a void∗

A constant expression (§10.4) that evaluates to 0 can be implicitly converted to a null pointer of
any pointer type. Similarly, a constant expression that evaluates to 0 can be implicitly converted to
a pointer-to-member type (§20.6). For example:
int∗ p = (1+2)∗(2∗(1−1)); // OK, but weird
Prefer nullptr (§7.2.2).

A T∗ can be implicitly converted to a const T∗ (§7.5). Similarly, a T& can be implicitly converted
to a const T&.


if (state&(badbit|failbit)) // stream not good
The extra parentheses are necessary because & has higher precedence than |

A ∆ B = (A ∪ B) – (A ∩ B) 
This is XOR, how beautiful it is!!!

max = (a<=b) ? b : a;
The parentheses around the condition are not necessary, but I find the code easier to read when they
are used.


void fct(int∗ p)
{
int i = (p) ? ∗p : std::runtime_error{"unexpected nullptr};
// ...
}//this is correct, a bit strange through



about ++ and --:
y=++x is equivalent to y=(x=x+1). // which means y = x and they both equal old x + 1
The value of x++, howev er, is the old value of x. For example, y=x++ is equivalent to y=(t=x,x=x+1,t)
// which means y = old x ; and x = old x + 1
// for example int x = 5; y = x++; // then y = 5, x = 6

BS explains thing so clear!

c/c++ way of copy string literal: while (∗p++ = ∗q++) ;

The delete operator may be applied only to a pointer returned by new or to the nullptr


do not use new to create local objects

The allocation and deallocation functions deal in untyped and uninitialized memory (often
called ‘‘raw memory’’), as opposed to typed objects.


The implementation model for {}-lists comes in three parts:
• If the {}-list is used as constructor arguments, the implementation is just as if you had used a
()-list. List elements are not copied except as by-value constructor arguments.
• If the {}-list is used to initialize the elements of an aggregate (an array or a class without a
constructor), each list element initializes an element of the aggregate. List elements are not
copied except as by-value arguments to aggregate element constructors.
• If the {}-list is used to construct an initializer_list object each list element is used to initialize
an element of the underlying array of the initializer_list. Elements are typically copied from
the initializer_list to wherever we use them.

For example, I might try to write a lambda to reverse the characters in a C-style string:
auto rev = [&rev](char∗ b, char∗ e)
{ if (1<e−b) { swap(∗b,∗−−e); rev(++b,e); } }; // error
However, that’s not possible because I cannot use an auto variable before its type has been deduced.
Instead, I can introduce a name and then use it:
void f(string& s1, string& s2)
{
function<void(char∗ b, char∗ e)> rev =
[&](char∗ b, char∗ e) { if (1<e−b) { swap(∗b,∗−−e); rev(++b,e); } };


A lambda that captures nothing can be assigned to a pointer to function of an appropriate type. For
example:
double (∗p1)(double) = [](double a) { return sqrt(a); };
double (∗p2)(double) = [&](double a) { return sqrt(a); }; // error : the lambda captures
double (∗p3)(int) = [](int a) { return sqrt(a); }; // error


The definition and all declarations for a function must specify the same type. Unfortunately, to preserve
C compatibility, a const is ignored at the highest level of an argument type. For example, this
is two declarations of the same function:
void f(int); // type is void(int)
void f(const int); // type is void(int)


Constructors (§2.3.2, §16.2.5) are technicallly not functions; in particular, they don’t return
a value, can initialize bases and members (§17.4), and can’t hav e their address taken.
• Destructors (§3.2.1.2, §17.2) can’t be overloaded and can’t hav e their address taken.
• Function objects (§3.4.3, §19.2.2) are not functions (they are objects) and can’t be overloaded,
but their operator()s are functions.
• Lambda expressions (§3.4.3, §11.4) are basically a shorthand for defining function objects.


int fac(int n)
{
return (n>1) ? n∗fac(n−1) : 1;
}


The store is reused after the function returns, so a pointer to a local non-static variable should
never be returned.



void h(int∗ p)
{
// ...
return g(p); // OK: equivalent to ‘‘g(p); return;’’
}


You can think of constexpr functions
as a restricted form of inline functions


Initialization of a static local variable does not lead to a data race (§5.3.1) unless you enter the
function containing it recursively or a deadlock occurs (§iso.6.7). That is, the C++ implementation
must guard the initialization of a local static variable with some kind of lock-free construct (e.g., a
call_once; §42.3.3). The effect of initializing a local static recursively is undefined.
// initializationwill not lead to data race, then will change it do in a multiple thread envs?


Unless a formal argument
(parameter) is a reference, a copy of the actual argument is passed to the function



int∗ find(int∗ first, int∗ last, int v) // find x in [first:last)
{
while (first!=last && ∗first!=v)
++first;
return first;
}
void g(int∗ p, int∗ q)
{
int∗ pp = find(p,q,'x');
// ...
}

Here, the caller’s copy of the argument, p, is not modified by the operations on find()’s copy, called
first. The pointer is passed by value.


Default arguments may be provided for trailing arguments only. For example:
int f(int, int =0, char∗ =nullptr); // OK
int g(int =0, int =0, char∗); //error
int h(int =0, int, char∗ =nullptr); // error
Note that the space between the ∗ and the = is significant (∗= is an assignment operator; §10.3):
int nasty(char∗=nullptr); // syntax erro

Return types are not considered in overload resolution. The reason is to keep resolution for an individual
operator (§18.2.1, §18.2.5) or function call context-independent.

A pointer to function must reflect the linkage of a function (§15.2.6). Neither linkage specification
nor noexcept may appear in type aliases:
using Pc = extern "C" void(int); // error : linkage specification in alias
using Pn = void(int) noexcept; // error : noexcept in alias


I recommend using macros only for conditional compilation (§12.6.1) and in particular for
include guards (§15.3.3).

In particular, the scope and storage class (§6.3.4, §6.4.2) of variables are not affected, so g1 is still a
global variable – and is still defined rather than just declared. To declare but not define a variable,
you must apply the keyword extern directly in the declaration. For example:
extern "C" int g3; // declaration, not definition
extern "C" { int g4; } // definition


An implementation in which C and C++ use the same calling conventions might accept the declarations
marked error as a language extension. However, even for compatible C and C++ implementations,
std::function (§33.5.3) or lambdas with any form of capture (§11.4.3) cannot cross the language
barrier.

Page 447 start part III


