A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in
extremely rare circumstances.

constexpr: meaning roughly ‘‘to be evaluated at compile time’’ (§10.4).

The size of an array must be a constant expression

a
reference cannot be made to refer to a different object after its initialization


Such a statement of what is assumed
to be true for a class is called a class invariant, or simply an invariant.

Also, it is not possible to change
the meaning of an operator for built-in types, so you can’t redefine + to subtract ints  ? cannot redefine plus?

The curious =0 syntax says the function is pure virtual; that is, some class derived
from Container must define the function  --- no baisc difenition , must override


Shape∗ read_shape(istream& is) // read shape descriptions from input stream is
{
// ... read shape header from is and find its Kind k ...
switch (k) {
case Kind::circle:
// read circle data {Point,int} into p and r
return new Circle{p,r};
case Kind::triangle:
// read triangle data {Point,Point,Point} into p1, p2, and p3
return new Triangle{p1,p2,p3};
case Kind::smiley:
// read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1 ,e2, and m
Smiley∗ ps = new Smiley{p,r};
ps−>add_eye(e1);
ps−>add_eye(e2);
ps−>set_mouth(m);
return ps;
}
}


void user()
{
std::vector<Shape∗> v;
while (cin)
v.push_back(read_shape(cin));
draw_all(v); //call draw() for each element
rotate_all(v,45); //call rotate(45) for each element
for (auto p : v) delete p; // remember to delete elements
}

// new within create and delete after use.

For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some
sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy,
and for abstract types it almost never is.


A move operation is applied when an rvalue reference is used as an initializer or as the righthand
side of an assignment.

Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer
to a base, we simply don’t know what members the derived class has (§3.2.2), so we can’t know
how to copy them. So, the best thing to do is usually to delete the default copy and move operations,
that is, to eliminate the default definitions of those two operations:

A pointer can be implicitly converted to a bool (§10.5.2.5). A non-null pointer converts to true;
pointers with the value nullptr convert to false.

The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned
instead of an int to gain one more bit to represent positive integers is almost never a good idea.
Attempts to ensure that some values are positive by declaring variables unsigned will typically be
defeated by the implicit conversion rules

A literal starting with zero followed by x or X (0x or 0X) is a hexadecimal (base 16) number. A
literal starting with zero but not followed by x or X is an octal (base 8) number.


The suffix U can be used to write explicitly unsigned literals. Similarly, the suffix L can be used
to write explicitly long literals. For example, 3 is an int, 3U is an unsigned int, and 3L is a long int.
Combinations of suffixes are allowed.

Choosing the right precision for a problem where the choice matters requires significant understanding
of floating-point computation. If you don’t hav e that understanding, get advice, take the
time to learn, or use double and hope for the best.


Suffixes not starting with _ are reserved for the standard library.

Sizes of C++ objects are expressed in terms of multiples of the size of a char, so by definition
the size of a char is 1. The size of an object or type can be obtained using the sizeof operator
(§10.3).



There must always be exactly one definition for each name in a C++ program (for the effects of
#include, see §15.2.3). However, there can be many declarations.
extern int error_number;
extern int error_number; // OK: redeclaration

Nonlocal names starting with an underscore are reserved for special facilities in the implementation
and the run-time environment, so such names should not be used in application programs. Similarly,
names starting with a double underscore (__) or an underscore followed by an uppercase letter
(e.g., _Foo) are reserved (

Try to maintain a consistent naming style. For example, capitalize names of user-defined types
and start names of non-type entities with a lowercase letter (for example, Shape and current_token).
Also, use all capitals for macros (if you must use macros (§12.6); for example, HACK) and never for
non-macros (not even for non-macro constants). Use underscores to separate words in an identifier;
number_of_elements is more readable than numberOfElements.

int x = 97;
void f3()
{
int x = x; // per verse: initialize x with its own (uninitialized) value
// it works, very funny. x hide global x after it's init.
}

159

