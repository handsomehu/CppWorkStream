A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in
extremely rare circumstances.

constexpr: meaning roughly ‘‘to be evaluated at compile time’’ (§10.4).

The size of an array must be a constant expression

a
reference cannot be made to refer to a different object after its initialization


Such a statement of what is assumed
to be true for a class is called a class invariant, or simply an invariant.

Also, it is not possible to change
the meaning of an operator for built-in types, so you can’t redefine + to subtract ints  ? cannot redefine plus?

The curious =0 syntax says the function is pure virtual; that is, some class derived
from Container must define the function  --- no baisc difenition , must override


Shape∗ read_shape(istream& is) // read shape descriptions from input stream is
{
// ... read shape header from is and find its Kind k ...
switch (k) {
case Kind::circle:
// read circle data {Point,int} into p and r
return new Circle{p,r};
case Kind::triangle:
// read triangle data {Point,Point,Point} into p1, p2, and p3
return new Triangle{p1,p2,p3};
case Kind::smiley:
// read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1 ,e2, and m
Smiley∗ ps = new Smiley{p,r};
ps−>add_eye(e1);
ps−>add_eye(e2);
ps−>set_mouth(m);
return ps;
}
}


void user()
{
std::vector<Shape∗> v;
while (cin)
v.push_back(read_shape(cin));
draw_all(v); //call draw() for each element
rotate_all(v,45); //call rotate(45) for each element
for (auto p : v) delete p; // remember to delete elements
}

// new within create and delete after use.

For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some
sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy,
and for abstract types it almost never is.


A move operation is applied when an rvalue reference is used as an initializer or as the righthand
side of an assignment.

Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer
to a base, we simply don’t know what members the derived class has (§3.2.2), so we can’t know
how to copy them. So, the best thing to do is usually to delete the default copy and move operations,
that is, to eliminate the default definitions of those two operations:

A pointer can be implicitly converted to a bool (§10.5.2.5). A non-null pointer converts to true;
pointers with the value nullptr convert to false.

The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned
instead of an int to gain one more bit to represent positive integers is almost never a good idea.
Attempts to ensure that some values are positive by declaring variables unsigned will typically be
defeated by the implicit conversion rules

A literal starting with zero followed by x or X (0x or 0X) is a hexadecimal (base 16) number. A
literal starting with zero but not followed by x or X is an octal (base 8) number.


The suffix U can be used to write explicitly unsigned literals. Similarly, the suffix L can be used
to write explicitly long literals. For example, 3 is an int, 3U is an unsigned int, and 3L is a long int.
Combinations of suffixes are allowed.

Choosing the right precision for a problem where the choice matters requires significant understanding
of floating-point computation. If you don’t hav e that understanding, get advice, take the
time to learn, or use double and hope for the best.


Suffixes not starting with _ are reserved for the standard library.

Sizes of C++ objects are expressed in terms of multiples of the size of a char, so by definition
the size of a char is 1. The size of an object or type can be obtained using the sizeof operator
(§10.3).



There must always be exactly one definition for each name in a C++ program (for the effects of
#include, see §15.2.3). However, there can be many declarations.
extern int error_number;
extern int error_number; // OK: redeclaration

Nonlocal names starting with an underscore are reserved for special facilities in the implementation
and the run-time environment, so such names should not be used in application programs. Similarly,
names starting with a double underscore (__) or an underscore followed by an uppercase letter
(e.g., _Foo) are reserved (

Try to maintain a consistent naming style. For example, capitalize names of user-defined types
and start names of non-type entities with a lowercase letter (for example, Shape and current_token).
Also, use all capitals for macros (if you must use macros (§12.6); for example, HACK) and never for
non-macros (not even for non-macro constants). Use underscores to separate words in an identifier;
number_of_elements is more readable than numberOfElements.

int x = 97;
void f3()
{
int x = x; // per verse: initialize x with its own (uninitialized) value
// it works, very funny. x hide global x after it's init.
}


Local variables and objects created on the free store (sometimes called dynamic objects or heap
objects; §11.2) are not initialized by default unless they are of user-defined types with a default
constructor (§17.3.3). For example:
void f()
{
int x; // x does not have a well-defined value
char buf[1024]; // buf[i] does not have a well-defined value
int∗ p {newint}; //*p does not have a well-defined value
char∗ q {new char[1024]}; // q[i] does not have a well-defined value
string s; // s=="" because of string’s default constructor
vector<char> v; // v=={} because of vector’s default constructor
string∗ ps {new string}; // *ps is "" because of string’s default constructor
// ...
}
x is defined within a funciton f(), is that the reason x is in heap rather than stack?




So, a classical lvalue is something that has identity and cannot be moved (because we could examine
it after a move), and a classical rvalue is anything that we are allowed to move from. The other
alternatives are prvalue (‘‘pure rvalue’’), glvalue (‘‘generalized lvalue’’), and xvalue (‘‘x’’ for ‘‘extraordinary’’
or ‘‘expert only’’; the suggestions for the meaning of this ‘‘x’’ hav e been quite imaginative).


Static objects can cause serious
problems in a multi-threaded program because they are shared among all threads and
typically require locking to avoid data races (§5.3.1, §42.3).


Thread-local objects; that is, objects declared thread_local (§42.2.8): such objects are created
when their thread is and destroyed when their thread is.

typedef void(∗PtoF)(int); // equivalent to ‘‘using PtoF = void(*)(int);’’   WTF

We cannot apply type specifiers, such as unsigned, to an alias. For example:
using Char = char;
using Uchar = unsigned Char; // error
using Uchar = unsigned char; // OK


Consequently, the smallest object that can be independently allocated and
pointed to using a built-in pointer type is a char


The ∗, meaning ‘‘pointer to,’’ is used as a suffix for a type name. Unfortunately, pointers to
arrays and pointers to functions need a more complicated notation:
int∗pi; //pointer to int
char∗∗ ppc; //pointer to pointer to char
int∗ ap[15]; // array of 15 pointers to ints
int (∗fp)(char∗); // pointer to function taking a char* argument; returns an int
int∗ f(char∗); //function taking a char* argument; returns a pointer to int

since BS said it is a suffix to type name, than I shall use this way consistantly.


You can read
void∗ as ‘‘pointer to an object of unknown type.’’

A pointer to any type of object can be assigned to a variable of type void∗, but a pointer to function
(§12.5) or a pointer to member (§20.6) cannot.In addition, a void∗ can be assigned to another
void∗, void∗s can be compared for equality and inequality, and a void∗ can be explicitly converted to
another type.


Page 174


