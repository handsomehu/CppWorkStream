A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in
extremely rare circumstances.

constexpr: meaning roughly ‘‘to be evaluated at compile time’’ (§10.4).

The size of an array must be a constant expression

a
reference cannot be made to refer to a different object after its initialization


Such a statement of what is assumed
to be true for a class is called a class invariant, or simply an invariant.

Also, it is not possible to change
the meaning of an operator for built-in types, so you can’t redefine + to subtract ints  ? cannot redefine plus?

The curious =0 syntax says the function is pure virtual; that is, some class derived
from Container must define the function  --- no baisc difenition , must override


Shape∗ read_shape(istream& is) // read shape descriptions from input stream is
{
// ... read shape header from is and find its Kind k ...
switch (k) {
case Kind::circle:
// read circle data {Point,int} into p and r
return new Circle{p,r};
case Kind::triangle:
// read triangle data {Point,Point,Point} into p1, p2, and p3
return new Triangle{p1,p2,p3};
case Kind::smiley:
// read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1 ,e2, and m
Smiley∗ ps = new Smiley{p,r};
ps−>add_eye(e1);
ps−>add_eye(e2);
ps−>set_mouth(m);
return ps;
}
}


void user()
{
std::vector<Shape∗> v;
while (cin)
v.push_back(read_shape(cin));
draw_all(v); //call draw() for each element
rotate_all(v,45); //call rotate(45) for each element
for (auto p : v) delete p; // remember to delete elements
}

// new within create and delete after use.

For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some
sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy,
and for abstract types it almost never is.


A move operation is applied when an rvalue reference is used as an initializer or as the righthand
side of an assignment.

Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer
to a base, we simply don’t know what members the derived class has (§3.2.2), so we can’t know
how to copy them. So, the best thing to do is usually to delete the default copy and move operations,
that is, to eliminate the default definitions of those two operations:

A pointer can be implicitly converted to a bool (§10.5.2.5). A non-null pointer converts to true;
pointers with the value nullptr convert to false.

The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned
instead of an int to gain one more bit to represent positive integers is almost never a good idea.
Attempts to ensure that some values are positive by declaring variables unsigned will typically be
defeated by the implicit conversion rules

A literal starting with zero followed by x or X (0x or 0X) is a hexadecimal (base 16) number. A
literal starting with zero but not followed by x or X is an octal (base 8) number.


The suffix U can be used to write explicitly unsigned literals. Similarly, the suffix L can be used
to write explicitly long literals. For example, 3 is an int, 3U is an unsigned int, and 3L is a long int.
Combinations of suffixes are allowed.


page 146
