A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in
extremely rare circumstances.

constexpr: meaning roughly ‘‘to be evaluated at compile time’’ (§10.4).

The size of an array must be a constant expression

a
reference cannot be made to refer to a different object after its initialization


Such a statement of what is assumed
to be true for a class is called a class invariant, or simply an invariant.

Also, it is not possible to change
the meaning of an operator for built-in types, so you can’t redefine + to subtract ints  ? cannot redefine plus?

The curious =0 syntax says the function is pure virtual; that is, some class derived
from Container must define the function  --- no baisc difenition , must override


Shape∗ read_shape(istream& is) // read shape descriptions from input stream is
{
// ... read shape header from is and find its Kind k ...
switch (k) {
case Kind::circle:
// read circle data {Point,int} into p and r
return new Circle{p,r};
case Kind::triangle:
// read triangle data {Point,Point,Point} into p1, p2, and p3
return new Triangle{p1,p2,p3};
case Kind::smiley:
// read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1 ,e2, and m
Smiley∗ ps = new Smiley{p,r};
ps−>add_eye(e1);
ps−>add_eye(e2);
ps−>set_mouth(m);
return ps;
}
}


void user()
{
std::vector<Shape∗> v;
while (cin)
v.push_back(read_shape(cin));
draw_all(v); //call draw() for each element
rotate_all(v,45); //call rotate(45) for each element
for (auto p : v) delete p; // remember to delete elements
}

// new within create and delete after use.

For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some
sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy,
and for abstract types it almost never is.


A move operation is applied when an rvalue reference is used as an initializer or as the righthand
side of an assignment.

Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer
to a base, we simply don’t know what members the derived class has (§3.2.2), so we can’t know
how to copy them. So, the best thing to do is usually to delete the default copy and move operations,
that is, to eliminate the default definitions of those two operations:

A pointer can be implicitly converted to a bool (§10.5.2.5). A non-null pointer converts to true;
pointers with the value nullptr convert to false.

The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned
instead of an int to gain one more bit to represent positive integers is almost never a good idea.
Attempts to ensure that some values are positive by declaring variables unsigned will typically be
defeated by the implicit conversion rules

A literal starting with zero followed by x or X (0x or 0X) is a hexadecimal (base 16) number. A
literal starting with zero but not followed by x or X is an octal (base 8) number.


The suffix U can be used to write explicitly unsigned literals. Similarly, the suffix L can be used
to write explicitly long literals. For example, 3 is an int, 3U is an unsigned int, and 3L is a long int.
Combinations of suffixes are allowed.

Choosing the right precision for a problem where the choice matters requires significant understanding
of floating-point computation. If you don’t hav e that understanding, get advice, take the
time to learn, or use double and hope for the best.


Suffixes not starting with _ are reserved for the standard library.

Sizes of C++ objects are expressed in terms of multiples of the size of a char, so by definition
the size of a char is 1. The size of an object or type can be obtained using the sizeof operator
(§10.3).



There must always be exactly one definition for each name in a C++ program (for the effects of
#include, see §15.2.3). However, there can be many declarations.
extern int error_number;
extern int error_number; // OK: redeclaration

Nonlocal names starting with an underscore are reserved for special facilities in the implementation
and the run-time environment, so such names should not be used in application programs. Similarly,
names starting with a double underscore (__) or an underscore followed by an uppercase letter
(e.g., _Foo) are reserved (

Try to maintain a consistent naming style. For example, capitalize names of user-defined types
and start names of non-type entities with a lowercase letter (for example, Shape and current_token).
Also, use all capitals for macros (if you must use macros (§12.6); for example, HACK) and never for
non-macros (not even for non-macro constants). Use underscores to separate words in an identifier;
number_of_elements is more readable than numberOfElements.

int x = 97;
void f3()
{
int x = x; // per verse: initialize x with its own (uninitialized) value
// it works, very funny. x hide global x after it's init.
}


Local variables and objects created on the free store (sometimes called dynamic objects or heap
objects; §11.2) are not initialized by default unless they are of user-defined types with a default
constructor (§17.3.3). For example:
void f()
{
int x; // x does not have a well-defined value
char buf[1024]; // buf[i] does not have a well-defined value
int∗ p {newint}; //*p does not have a well-defined value
char∗ q {new char[1024]}; // q[i] does not have a well-defined value
string s; // s=="" because of string’s default constructor
vector<char> v; // v=={} because of vector’s default constructor
string∗ ps {new string}; // *ps is "" because of string’s default constructor
// ...
}
x is defined within a funciton f(), is that the reason x is in heap rather than stack?




So, a classical lvalue is something that has identity and cannot be moved (because we could examine
it after a move), and a classical rvalue is anything that we are allowed to move from. The other
alternatives are prvalue (‘‘pure rvalue’’), glvalue (‘‘generalized lvalue’’), and xvalue (‘‘x’’ for ‘‘extraordinary’’
or ‘‘expert only’’; the suggestions for the meaning of this ‘‘x’’ hav e been quite imaginative).


Static objects can cause serious
problems in a multi-threaded program because they are shared among all threads and
typically require locking to avoid data races (§5.3.1, §42.3).


Thread-local objects; that is, objects declared thread_local (§42.2.8): such objects are created
when their thread is and destroyed when their thread is.

typedef void(∗PtoF)(int); // equivalent to ‘‘using PtoF = void(*)(int);’’   WTF

We cannot apply type specifiers, such as unsigned, to an alias. For example:
using Char = char;
using Uchar = unsigned Char; // error
using Uchar = unsigned char; // OK


Consequently, the smallest object that can be independently allocated and
pointed to using a built-in pointer type is a char


The ∗, meaning ‘‘pointer to,’’ is used as a suffix for a type name. Unfortunately, pointers to
arrays and pointers to functions need a more complicated notation:
int∗pi; //pointer to int
char∗∗ ppc; //pointer to pointer to char
int∗ ap[15]; // array of 15 pointers to ints
int (∗fp)(char∗); // pointer to function taking a char* argument; returns an int
int∗ f(char∗); //function taking a char* argument; returns a pointer to int

since BS said it is a suffix to type name, than I shall use this way consistantly.


You can read
void∗ as ‘‘pointer to an object of unknown type.’’

A pointer to any type of object can be assigned to a variable of type void∗, but a pointer to function
(§12.5) or a pointer to member (§20.6) cannot.In addition, a void∗ can be assigned to another
void∗, void∗s can be compared for equality and inequality, and a void∗ can be explicitly converted to
another type.


There is no built-in copy operation for arrays. You cannot initialize one array with another (not
ev en of exactly the same type), and there is no array assignment:


R"∗∗∗("quoted string containing the usual terminator ("))")∗∗∗"
// "quoted string containing the usual terminator ("))"


It usually surprises people to find that a[j]==j[a]. For example, 3["Texas"]=="Texas"[3]=='a'.

Subtraction of pointers is defined only when both pointers point to elements of the same array

When subtracting a pointer p
from another pointer q, q−p, the result is the number of array elements in the sequence [p:q)

// q is not include


To
declare a pointer itself, rather than the object pointed to, to be a constant, we use the declarator
operator ∗const instead of plain ∗.


The declarator operator that makes a pointer constant is ∗const. There is no const∗ declarator operator,
so a const appearing before the ∗ is taken to be part of the base type.

Thus, we cannot have a pointer to a reference. Furthermore, we cannot define
an array of references. In that sense, a reference is not an object.


// you can init a const reference from a rvalue(indirectly).
double& dr = 1; // error : lvalue needed
const double& cdr {1}; // OK
The interpretation of this last initialization might be:
double temp = double{1}; // first create a temporar y with the right value
const double& cdr {temp}; // then use the temporar y as the initializer for cdr
A



using rr_i = int&&;
using lr_i = int&;
using rr_rr_i = rr_i&&; // ‘‘int && &&’’ is an int&&
using lr_rr_i = rr_i&; // ‘‘int && &’’ is an int&
using rr_lr_i = lr_i&&; // ‘‘int & &&’’ is an int&
using lr_lr_i = lr_i&; // ‘‘int & &’’ is an int&
In other words, lvalue reference always wins.This makes sense: nothing we can do with types can
change the fact that an lvalue reference refers to an lvalue. This is sometimes known as reference
collapse.

It is not possible to (re)define an operator for a pair of built-in types, such as pointers


It is usually best to order members for readability and sort them by size only if there is a
demonstrated need to optimize.


template<typename T>
void mycopy(T∗ to, const T∗ from, int count)
{
if (is_pod<T>::value)
memcpy(to,from,count∗sizeof(T));
else
for (int i=0; i!=count; ++i)
to[i]=from[i];
}



struct PPN { // R6000 Physical Page Number
unsigned int PFN : 22; // Page Frame Number
int : 3; // unused
unsigned int CCA : 3; // Cache Coherency Algorithm
bool nonreachable : 1;
bool dirty : 1;
bool valid : 1;
bool global : 1;
};
This example also illustrates the other main use of fields: to name parts of an externally imposed
layout. A field must be of an integral or enumeration type (§6.2.1). It is not possible to take the
address of a field. Apart from that, however, it can be used exactly like other variables. Note that a
bool field really can be represented by a single bit.

enum E1 { a, b };
enum class E2 { a, b };
void f(E1 x, E2 y)
{
if (x) // OK
// ...
if (y) // error : no conversion to bool
// ...
if (y==E2::a) // OK
// ...
}


switch (val) { // beware
case 1:
cout << "case 1\n";
case 2:
cout << "case 2\n";
default:
cout << "default: case not found\n";
}
Invoked with val==1, the output will greatly surprise the uninitiated:
case 1
case 2
default: case not found

constexpr string ss = s; // error : s is not a constant expression
constexpr int yy = y; // error : sqr t(x) is not a constant expression
The reasons for the errors are that string is not a literal type (§10.4.3) and sqrt() is not a constexpr
function (§12.1.6).



When working with constexpr, the key thing to remember is that constexpr is all about values.
There are no objects that can change values or side effects here: constexpr provides a miniature
compile-time functional programming language.

Note that a pointer to function or a pointer to member cannot be implicitly
converted to a void∗

A constant expression (§10.4) that evaluates to 0 can be implicitly converted to a null pointer of
any pointer type. Similarly, a constant expression that evaluates to 0 can be implicitly converted to
a pointer-to-member type (§20.6). For example:
int∗ p = (1+2)∗(2∗(1−1)); // OK, but weird
Prefer nullptr (§7.2.2).

A T∗ can be implicitly converted to a const T∗ (§7.5). Similarly, a T& can be implicitly converted
to a const T&.


if (state&(badbit|failbit)) // stream not good
The extra parentheses are necessary because & has higher precedence than |

A ∆ B = (A ∪ B) – (A ∩ B) 
This is XOR, how beautiful it is!!!

max = (a<=b) ? b : a;
The parentheses around the condition are not necessary, but I find the code easier to read when they
are used.


void fct(int∗ p)
{
int i = (p) ? ∗p : std::runtime_error{"unexpected nullptr};
// ...
}//this is correct, a bit strange through



about ++ and --:
y=++x is equivalent to y=(x=x+1). // which means y = x and they both equal old x + 1
The value of x++, howev er, is the old value of x. For example, y=x++ is equivalent to y=(t=x,x=x+1,t)
// which means y = old x ; and x = old x + 1
// for example int x = 5; y = x++; // then y = 5, x = 6

BS explains thing so clear!

c/c++ way of copy string literal: while (∗p++ = ∗q++) ;

The delete operator may be applied only to a pointer returned by new or to the nullptr


do not use new to create local objects

The allocation and deallocation functions deal in untyped and uninitialized memory (often
called ‘‘raw memory’’), as opposed to typed objects.


The implementation model for {}-lists comes in three parts:
• If the {}-list is used as constructor arguments, the implementation is just as if you had used a
()-list. List elements are not copied except as by-value constructor arguments.
• If the {}-list is used to initialize the elements of an aggregate (an array or a class without a
constructor), each list element initializes an element of the aggregate. List elements are not
copied except as by-value arguments to aggregate element constructors.
• If the {}-list is used to construct an initializer_list object each list element is used to initialize
an element of the underlying array of the initializer_list. Elements are typically copied from
the initializer_list to wherever we use them.

For example, I might try to write a lambda to reverse the characters in a C-style string:
auto rev = [&rev](char∗ b, char∗ e)
{ if (1<e−b) { swap(∗b,∗−−e); rev(++b,e); } }; // error
However, that’s not possible because I cannot use an auto variable before its type has been deduced.
Instead, I can introduce a name and then use it:
void f(string& s1, string& s2)
{
function<void(char∗ b, char∗ e)> rev =
[&](char∗ b, char∗ e) { if (1<e−b) { swap(∗b,∗−−e); rev(++b,e); } };


A lambda that captures nothing can be assigned to a pointer to function of an appropriate type. For
example:
double (∗p1)(double) = [](double a) { return sqrt(a); };
double (∗p2)(double) = [&](double a) { return sqrt(a); }; // error : the lambda captures
double (∗p3)(int) = [](int a) { return sqrt(a); }; // error


The definition and all declarations for a function must specify the same type. Unfortunately, to preserve
C compatibility, a const is ignored at the highest level of an argument type. For example, this
is two declarations of the same function:
void f(int); // type is void(int)
void f(const int); // type is void(int)


Constructors (§2.3.2, §16.2.5) are technicallly not functions; in particular, they don’t return
a value, can initialize bases and members (§17.4), and can’t hav e their address taken.
• Destructors (§3.2.1.2, §17.2) can’t be overloaded and can’t hav e their address taken.
• Function objects (§3.4.3, §19.2.2) are not functions (they are objects) and can’t be overloaded,
but their operator()s are functions.
• Lambda expressions (§3.4.3, §11.4) are basically a shorthand for defining function objects.


int fac(int n)
{
return (n>1) ? n∗fac(n−1) : 1;
}


The store is reused after the function returns, so a pointer to a local non-static variable should
never be returned.



void h(int∗ p)
{
// ...
return g(p); // OK: equivalent to ‘‘g(p); return;’’
}


You can think of constexpr functions
as a restricted form of inline functions


Initialization of a static local variable does not lead to a data race (§5.3.1) unless you enter the
function containing it recursively or a deadlock occurs (§iso.6.7). That is, the C++ implementation
must guard the initialization of a local static variable with some kind of lock-free construct (e.g., a
call_once; §42.3.3). The effect of initializing a local static recursively is undefined.
// initializationwill not lead to data race, then will change it do in a multiple thread envs?


Unless a formal argument
(parameter) is a reference, a copy of the actual argument is passed to the function



int∗ find(int∗ first, int∗ last, int v) // find x in [first:last)
{
while (first!=last && ∗first!=v)
++first;
return first;
}
void g(int∗ p, int∗ q)
{
int∗ pp = find(p,q,'x');
// ...
}

Here, the caller’s copy of the argument, p, is not modified by the operations on find()’s copy, called
first. The pointer is passed by value.


Default arguments may be provided for trailing arguments only. For example:
int f(int, int =0, char∗ =nullptr); // OK
int g(int =0, int =0, char∗); //error
int h(int =0, int, char∗ =nullptr); // error
Note that the space between the ∗ and the = is significant (∗= is an assignment operator; §10.3):
int nasty(char∗=nullptr); // syntax erro

Return types are not considered in overload resolution. The reason is to keep resolution for an individual
operator (§18.2.1, §18.2.5) or function call context-independent.

A pointer to function must reflect the linkage of a function (§15.2.6). Neither linkage specification
nor noexcept may appear in type aliases:
using Pc = extern "C" void(int); // error : linkage specification in alias
using Pn = void(int) noexcept; // error : noexcept in alias


I recommend using macros only for conditional compilation (§12.6.1) and in particular for
include guards (§15.3.3).

In particular, the scope and storage class (§6.3.4, §6.4.2) of variables are not affected, so g1 is still a
global variable – and is still defined rather than just declared. To declare but not define a variable,
you must apply the keyword extern directly in the declaration. For example:
extern "C" int g3; // declaration, not definition
extern "C" { int g4; } // definition


An implementation in which C and C++ use the same calling conventions might accept the declarations
marked error as a language extension. However, even for compatible C and C++ implementations,
std::function (§33.5.3) or lambdas with any form of capture (§11.4.3) cannot cross the language
barrier.


By default, declare a constructor that can be called with a single argument explicit. You need a
good reason not to do so (as for complex). If you define an implicit constructor, it is best to document
your reason or a maintainer may suspect that you were forgetful (or ignorant).

We can define a member of a class to be mutable, meaning that it can be modified even in a const
object:

In multi-threaded code, static data members require some kind of locking or access discipline to
avoid race conditions


A member class (often called a nested class) can refer to types and static members of its enclosing
class. It can only refer to non-static members when it is given an object of the enclosing class to
refer to.

A nested class has access to members of its enclosing class, even to private members (just as a
member function has), but has no notion of a current object of the enclosing class.



template<typename T>
void Tree::Node::f(Tree∗ p)
{
top = right; // error : no object of type Tree specified
p−>top = right; // OK
value_type v = left−>value; // OK: value_type is not associated with an object
}

A class does not have any special access rights to the members of its nested class. For example:
template<typename T>
void Tree::g(Tree::Node∗ p)
{
value_type val = right−>value; //error : no object of type Tree::Node
value_type v = p−>right−>value; // error : Node::r ight is private
p−>f(this); //OK
}


Constructors and destructors interact correctly with class hierarchies (§3.2.4, Chapter 20). A constructor
builds a class object ‘‘from the bottom up’’:
[1] first, the constructor invokes its base class constructors,
[2] then, it invokes the member constructors, and
[3] finally, it executes its own body.
A destructor ‘‘tears down’’ an object in the reverse order:
[1] first, the destructor executes its own body,
[2] then, it invokes its member destructors, and
[3] finally, it inv okes its base class destructors.

A class can only have one desctructor and with on argument.

Consider a container that
(like std::vector) maintains a pool of memory into which it can grow and shrink (e.g., using
push_back() and pop_back()). When we add an element, the container must invoke its constructor
for a specific address:
void C::push_back(const X& a)
{
// ...
new(p) X{a}; // copy constr uct an X with the value a in address p
// ...
}
This use of a constructor is known as ‘‘placement new’’ (§11.2.4).
Conversely, when we remove an element, the container needs to invoke its destructor:
void C::pop_back()
{
// ...
p−>˜X(); // destroy the X in address p
}

class Nonlocal {
public:
// ...
void destroy() { this−>˜Nonlocal(); } // explicit destruction
private:
// ...
˜Nonlocal(); //don’t destroy implicitly
};
void user()
{
Nonlocal x; // error : cannot destroy a Nonlocal
X∗ p = new Nonlocal; // OK
// ...
delete p; // error : cannot destroy a Nonlocal
p.destroy(); //OK
}

If you want guaranteed initialization or simply dislike surprises,
supply an initializer, such as {}.

If a class has a private non-static data member, it needs a constructor to initialize it.


Note that the default constructor (§17.3.3) disappears when you define a constructor requiring arguments;
after all, X(int) states that an int is required to construct an X. Howev er, the copy constructor
does not disappear (§17.3.3); the assumption is that an object can be copied (once properly constructed).

Note that the {}-initializer notation does not allow narrowing (§2.2.2). That is another reason to
prefer the {} style over () or =.


References and consts must be initialized (§7.7, §7.5). Therefore, a class containing such members
cannot be default constructed unless the programmer supplies in-class member initializers
(§17.4.4) or defines a default constructor that initializes them (§17.4.1).


For selecting a constructor, default and initializer
lists take precedence. Consider:
struct X {
X(initializer_list<int>);
X();
X(int);
};
X x0 {}; // empty list: default constructor or initializer-list constructor? (the default constructor)
X x1 {1}; // one integer: an int argument or a list of one element? (the initializer-list constructor)


The rules are:
• If either a default constructor or an initializer-list constructor could be invoked, prefer the
default constructor.
• If both an initializer-list constructor and an ‘‘ordinary constructor’’ could be invoked, prefer
the initializer-list constructor.


An initializer_list<T> is passed by value. That is required by the overload resolution rules
(§12.3) and does not impose overhead because an initializer_list<T> object is just a small handle
(typically two words) to an array of Ts.


That is, a member-style initializer using the class’s own name (its constructor name) calls another
constructor as part of the construction. Such a constructor is called a delegating constructor (and
occasionally a forwarding constructor).
You cannot both delegate and explicitly initialize a member.


If a member is initialized by both an in-class initializer and a constructor, only the constructor’s
initialization is done (it ‘‘overrides’’ the default).

It is a bad idea to hide subtle dependencies on global data in member initializers.


A copy constructor and a copy assignment differ in that a copy constructor initializes uninitialized
memory, whereas the copy assignment operator must correctly deal with an object that has already
been constructed and may own resources.


The Matrix copy assignment operator has the property that if a copy of an element throws an
exception, the target of the assignment may be left with a mixture of its old value and the new.
That is, that Matrix assignment provided the basic guarantee, but not the strong guarantee (§13.2).
If that is not considered acceptable, we can avoid it by the fundamental technique of first making a
copy and then swapping representations:
Matrix& Matrix::operator=(const Matrix& m) // copy assignment
{
Matrix tmp {m}; // make a copy
swap(tmp,∗this); // swap tmp’s representation with *this’s
return ∗this;
}

Copy operations that provide equivalence and independence
lead to simpler and more maintainable code.


Here I violated the rule of independence. After the ‘‘copy’’ of x into y, we can manipulate part of
x’s state through y. This is sometimes called shallow copy and (too) often praised for ‘‘efficiency.’’
The obvious alternative of copying the complete state of an object is called deep copy. Often, the
better alternative to deep copy is not a shallow copy, but a move operation, which minimizes copying
without adding complexity (§3.3.2, §17.5.2).


copy on write:
Note that an immutable shared state is not a problem. Unless we compare addresses, we cannot
tell whether two equal values happen to be represented as one or two copies. This is a useful observation
because many copies are never modified. For example, objects passed by value are rarely
written to. This observation leads to the notion of copy-on-write. The idea is that a copy doesn’t
actually need independence until a shared state is written to, so we can delay the copying of the
shared state until just before the first write to it. Consider:
class Image {
public:
// ...
Image(const Image& a); // copy constr uctor
// ...
void write_block(Descriptor);
// ...
private:
Representation∗ clone(); // copy *rep
Representation∗ rep;
bool shared;
};
Assume that a Representation can be huge and that a write_block() is expensive compared to testing
a bool. Then, depending on the use of Images, it can make sense to implement the copy constructor
as a shallow copy:
Image::Image(const Image& a) // do shallow copy and prepare for copy-on-wr ite
:rep{a.rep},
shared{true}
{
}
We protect the argument to that copy constructor by copying the Representation before a write:void write_block(Descriptor d)
{
if (shared) {
rep =clone(); // make a copy of *rep
shared = false; // no more sharing
}
// ... now we can safely write to our own copy of rep ...
}// a very wise way


A pointer to a derived class implicitly converts to a pointer to its public base class.

The variables b2 and bb contain copies of the Base part of d, that is, a copy of d.b. The member d.d
is not copied. This phenomenon is called slicing. It may be exactly what you intended (e.g., see
the copy constructor for D in §17.5.1.2 where we pass selected information to a base class), but typically
it is a subtle bug. If you don’t want slicing, you have two major tools to prevent it:
[1] Prohibit copying of the base class: delete the copy operations (§17.6.4).
[2] Prevent conversion of a pointer to a derived to a pointer to a base: make the base class a
private or protected base (§20.5).

How does the compiler know when it can use a move operation rather than a copy operation?
In a few cases, such as for a return value, the language rules say that it can (because the next action
is defined to destroy the element). However, in general we have to tell it by giving an rvalue reference
argument. For example:
template<class T>
void swap(T& a, T& b) // "perfect swap" (almost)
{
T tmp = std::move(a);
a = std::move(b);
b = std::move(tmp);
}

For a return value, the move constructor is chosen.


The move() is a standard-library function returning an rvalue reference to its argument (§35.5.1):
move(x) means ‘‘give me an rvalue reference to x.’’ That is, std::move(x) does not move anything;
instead, it allows a user to move x.


you have to be careful about data structures containing pointers (§3.3.1). In particular,
don’t assume that a moved-from pointer is set to nullptr.

• If the programmer declares any constructor for a class, the default constructor is not generated
for that class.
• If the programmer declares a copy operation, a move operation, or a destructor for a class,
no copy operation, move operation, or destructor is generated for that class.
Unfortunately, the second rule is only incompletely enforced: for backward compatibility, copy
constructors and copy assignments are generated even if a destructor is defined. However, that generation
is deprecated in the ISO standard (§iso.D), and you should expect a modern compiler to
warn against it.


Wherever possible
[1] Establish an invariant in a constructor (including possibly resource acquisition).
[2] Maintain the invariant with copy and move operations (with the usual names and types).
[3] Do any needed cleanup in the destructor (incl. possibly resource release).

In general, if a class has a pointer member, the
default copy and move operations should be considered suspicious. If that pointer member represents
ownership, memberwise copy is wrong. If that pointer member does not represent ownership
and memberwise copy is appropriate, explicit =default and a comment are most likely a good idea.


If we wanted copy construction, we could define something like:
template<class T>
class Handle {
// ...
Handle(const T& a) :p{new T{∗a.p}} { } // clone
};

We defined copy assignment, so we must also define the destructor. 


[1] Is a default constructor needed (because the default one is not adequate or has been suppressed
by another constructor)?
[2] Is a destructor needed (e.g., because some resource needs to be released)?
[3] Are copy operations needed (because the default copy semantics is not adequate, e.g.,
because the class is meant to be a base class or because it contains pointers to objects that
must be deleted by the class)?
[4] Are move operations needed (because the default semantics is not adequate, e.g., because
an empty object doesn’t make sense)?


template<class T>
T∗ clone(T∗ p) // return copy of *p
{
return new T{∗p};
};
Foo∗ clone(Foo∗) = delete; // don’t try to clone a Foo
void f(Shape∗ ps, Foo∗ pf)
{
Shape∗ ps2 = clone(ps); // fine
Foo∗ pf2 = clone(pf); // error : clone(Foo*) deleted
}

In addition, user-defined literals (§19.2.6) are defined by using the operator"" notation. This is a
kind of syntactic subterfuge because there is no operator called "". Similarly, operator T() defines a
conversion to a type T


The operators operator= (§18.2.2), operator[] (§19.2.1), operator() (§19.2.2), and operator−>
(§19.2.3) must be non-static member functions.

The default meaning of &&, ||, and , (comma) involves sequencing: the first operand is evaluated
before the second (and for && and || the second operand is not always evaluated). This special rule
does not hold for user-defined versions of &&, ||, and , (comma); instead these operators are treated
exactly like other binary operators.


If a function simply passes an object to another function, an rvalue reference argument should
be used


Consider a binary operator @. If x is of type X and y is of type Y, x@y is resolved like this:
• IfX is a class, look for operator@ as a member of X or as a member of a base of X; and
• look for declarations of operator@ in the context surrounding x@y; and
• ifX is defined in namespace N, look for declarations of operator@ in N; and
• ifY is defined in namespace M, look for declarations of operator@ in M.


If we don’t want implicit conversions, we can use explicit to suppress them (§16.2.6, §18.4.2).
An operator[]() must be a non-static member function.


Overloading −> is primarily useful for creating ‘‘smart pointers,’’ that is, objects that act like pointers
and in addition perform some action whenever an object is accessed through them. The standard-
library ‘‘smart pointers’’ unique_ptr and shared_ptr (§5.2.1) provide operator −>.


Operator −> must be a non-static member function. If used, its return type must be a pointer or
an object of a class to which you can apply −>.


A more selective, and often better, approach is to supply these operations for a specific class.
This class might be the base for many derived classes. For example, we might like to hav e a class
Employee provide a specialized allocator and deallocator for itself and all of its derived classes:
class Employee {
public:
// ...
void∗ operator new(siz e_t);
void operator delete(void∗, siz e_t);
void∗ operator new[](siz e_t);
void operator delete[](void∗, siz e_t);
};


Member operator new()s and operator delete()s are implicitly static members. Consequently, they
don’t hav e a this pointer and do not modify an object. They provide storage that a constructor can
initialize and a destructor can clean up.


A template literal operator is a literal operator that takes its argument as a template parameter
pack, rather than as a function argument.


In particular, I used a form of union called an anonymous union
(§8.3.2), which is specifically designed to allow a class to manage alternative representations of
objects.


Thus, a friend function should be explicitly declared in an enclosing scope or take an argument of
its class or a class derived from that. If not, the friend cannot be called.

Interface inheritance is often referred to as run-time polymorphism (or dynamic polymorphism). In
contrast, the uniform use of classes not related by inheritance provided by templates (§3.4, Chapter
23) is often referred to as compile-time polymorphism (or static polymorphism).

A member of a derived class can use the public – and protected (see §20.5) – members of a base
class as if they were declared in the derived class itself.
However, a derived class cannot access private members of a base class:


Typically, the cleanest solution is for the derived class to use only the public members of its
base class. For example:
void Manager::print() const
{
Employee::print(); // print Employee infor mation
cout << level; // print Manager-specific infor mation
// ...
}
Note that :: must be used because print() has been redefined in Manager. Such reuse of names is typical.
The unwary might write this:
void Manager::print() const
{
print(); // oops!
// print Manager-specific infor mation
}
The result is a sequence of recursive calls ending with some form of program crash.


As usual, constructors and destructors are as essential:
• Objects are constructed from the bottom up (base before member and member before
derived) and destroyed top-down (derived before member and member before base);
§17.2.3.
• Each class can initialize its members and bases (but not directly members or bases of its
bases); §17.4.1.
• Typically, destructors in a hierarchy need to be virtual; §17.2.5.
• Copy constructors of classes in a hierarchy should be used with care (if at all) to avoid slicing;
§17.5.1.4.
• The resolution of a virtual function call, a dynamic_cast, or a typeid() in a constructor or destructor
reflects the stage of construction and destruction (rather than the type of the yet-tobe-
completed object); §22.4.


A function from a derived class with the same name and the same set of argument types as a virtual
function in a base is said to override the base class version of the virtual function.


A virtual function invoked from a constructor or a destructor reflects that the object is partially
constructed or partially destroyed (§22.4). It is therefore typically a bad idea to call a virtual function
from a constructor or a destructor.

for larger hierarchies
more specific controls are useful:
• virtual: The function may be overridden (§20.3.2).
• =0: The function must be virtual and must be overridden (§20.4).
• override: The function is meant to override a virtual function in a base class (§20.3.4.1).
• final: The function is not meant to be overridden (§20.3.4.2).


The override specifier comes last in a declaration, after all other parts.


struct Node { // interface class
virtual Type type() = 0;
// ...
};
class If_statement : public Node {
public:
Type type() override final; // prevent further overr iding
// ...
};


We can make every virtual member function of a class final; just add final after the class name. 
For good and bad, adding final to the class not only prevents overriding, it also prevents further
derivation from a class.
For example:
class For_statement final : public Node {
public:
Type type() override;
// ...
};


A final specifier is not part of the type of a function and cannot be repeated in an out-of-class
definition.


Functions do not overload across scopes (§12.3.3). For example:
struct Base {
void f(int);
};
struct Derived : Base {
void f(double);
};
void use(Derived d)
{
d.f(1); // call Derived::f(double)
Base& br = d
br.f(1); // call Base::f(int)
}


We solve the problem by simply saying that the constructors should be inherited:
template<class T>
struct Vector : std::vector<T> {
using vector<T>::vector; // inherit constr uctors

There is a relaxation of the rule that the type of an overriding function must be the same as the type
of the virtual function it overrides. That is, if the original return type was B∗, then the return type of
the overriding function may be D∗, provided B is a public base of D. Similarly, a return type of B&
may be relaxed to D&. This is sometimes called the covariant return rule.
This relaxation applies only to return types that are pointers or references, and not to ‘‘smart
pointers’’ such as unique_ptr (§5.2.1).


A class with one or more pure virtual functions is an abstract class, and no objects of that abstract
class can be created:

A pure virtual function that is not defined in a derived class remains a pure virtual function, so the
derived class is also an abstract class. This allows us to build implementations in stages:
class Polygon : public Shape { // abstract class
public:
bool is_closed() const override { return true; }
// ... draw and rotate not overr idden ...
};
Polygon b {p1,p2,p3,p4}; // error : declaration of object of abstract class Polygon
Polygon is still abstract because we did not override draw() and rotate(). Only when that is done do
we have a class from which we can create objects

The compiler may decide for m2 to precede m1 in the layout of an S object. Such reordering could
come as a surprise to the programmer and is implementation-dependent, so don’t use multiple
access specifiers for data members without good reason.


Like a member, a base class can be declared private, protected, or public. For example:
class X : public B { /* ... */ };
class Y : protected B { /* ... */ };
class Z : private B { /* ... */ };
The different access specifiers serve different design needs:
• public derivation makes the derived class a subtype of its base. For example, X is a kind of
B. This is the most common form of derivation.
• private bases are most useful when defining a class by restricting the interface to a base so
that stronger guarantees can be provided. For example, B is an implementation detail of Z.
The Vector of pointers template that adds type checking to its Vector<void∗> base from §25.3
is a good example.
• protected bases are useful in class hierarchies in which further derivation is the norm. Like
private derivation, protected derivation is used to represent implementation details. The
Ival_slider from §21.2.2 is a good example.

The access specifier for a base class can be left out. In that case, the base defaults to a private base
for a class and a public base for a struct. For example:
class XX : B { /* ... */ }; // B is a private base
struct YY : B { /* ... */ }; // B is a public base

The access specifier for a base class controls the access to members of the base class and the
conversion of pointers and references from the derived class type to the base class type. Consider a
class D derived from a base class B:
• IfB is a private base, its public and protected members can be used only by member functions
and friends of D. Only friends and members of D can convert a D∗ to a B∗.
• IfB is a protected base, its public and protected members can be used only by member functions
and friends of D and by member functions and friends of classes derived from D. Only
friends and members of D and friends and members of classes derived from D can convert a
D∗ to a B∗.
• IfB is a public base, its public members can be used by any function. In addition, its protected
members can be used by members and friends of D and members and friends of
classes derived from D. Any function can convert a D∗ to a B∗.


static is not ambiguous
struct B {
int m;
static int sm;
// ...
}
class X1 : public B { /* ... */ } ;
class X2 : public B { /* ... */ } ;
class XX : public X1, public X2 { /* ... */ };
XX∗ pxx = new XX;
int i1 = pxx−>m; // error, ambiguous: XX::X1::B::m or XX::X2::B::m?
int i2 = pxx−>sm; // OK: there is only one B::sm in an XX (sm is a static member)

A pointer to member cannot be assigned to a void∗ or any other ordinary pointer. A null pointer
(e.g., nullptr) can be assigned to a pointer to member and then represents ‘‘no member.’’


Pointer to member function, very tricky, did not copy notes, same as pointer to data member
A derived class has at least the members that it inherits from its base classes. Often it has more.
This implies that we can safely assign a pointer to a member of a base class to a pointer to a member
of a derived class, but not the other way around. This property is often called contravariance.
class Text : public Std_interface {
public:
void start();
void suspend();
// ...
virtual void print();
private:
vector s;
};
void (Std_interface::∗ pmi)() = &Text::print; // error
void (Text::∗pmt)() = &Std_interface::start; // OK


To some people, the words ‘‘multiple inheritance’’ indicate something complicated and scary.
However, the use of one base class for implementation details and another for interface (the abstract
class) is common to all languages supporting inheritance and compile-time checked interfaces. In
particular, the use of the abstract class Ival_box is almost identical to the use of an interface in Java
or C#.

A function declared in a derived class overrides all functions of the same name and type in its base
classes. Typically, that is exactly the right thing to do because it is generally a bad idea to use the
same name for operations with different semantics in a single class.


Given this apparently minor change to Storable, we must change the design of Radio. All parts of
an object must share a single copy of Storable. Otherwise, we could get two parts of something
derived from Storable multiple times using different files. We avoid replication by declaring a base
virtual: every virtual base of a derived class is represented by the same (shared) object.



class Transmitter : public virtual Storable {
public:
void write() override;
// ...
};
class Receiver : public virtual Storable {
public:
void write() override;
// ...
};
class Radio : public Transmitter, public Receiver {
public:
void write() override;
// ...
};


Knowledge of a virtual base and the obligation to initialize it ‘‘bubbles
up’’ to the most derived class. A virtual base is always considered a direct base of its most derived 
class. The fact that both B and C initialized V is irrelevant because the compiler has no idea which
of those two initializers to prefer. Thus, only the initializer provided by the most derived class is
used.

In practice, this is not quite as localized as we would prefer. In particular, if we derive another
class, DD, from D, then DD has to do work to initialize the virtual bases. Unless we can simply
inherit D’s constructors (§20.3.5.1), that can be a nuisance. That ought to encourage us not to
overuse virtual base classes.
This logical problem with constructors does not exist for destructors. They are simply invoked
in reverse order of construction (§20.2.2). In particular, a destructor for a virtual base is invoked
exactly once.


A class that provides some – but not all – of the implementation for a virtual base class is often
called a mixin.


A dynamic_cast to void∗ can be used to determine the address of the beginning of an object of polymorphic
type. For example:
void g(Ival_box∗ pb, Date∗ pd)
{
void∗ pb2 = dynamic_cast<void∗>(pb); // OK
void∗ pd2 = dynamic_cast<void∗>(pd); // error : Date not polymorphic
}


There is no dynamic_cast from void∗ (because there would be no way of knowing
where to find the vptr; §22.2.3).


The difference in results of a failed dynamic pointer cast and a failed dynamic reference cast
reflects a fundamental difference between references and pointers. If a user wants to protect against
bad casts to references, a suitable handler must be provided. For example:
void g(BB_ival_slider& slider, BB_ival_dial& dial)
{
try {
fp(&slider); // pointer to BB_ival_slider passed as Ival_box*
fr(slider); // reference to BB_ival_slider passed as Ival_box&
fp(&dial); // pointer to BB_ival_dial passed as Ival_box*
fr(dial); // dial passed as Ival_box
}
catch (bad_cast) { // §30.4.1.1
// ...
}
}

A dynamic_cast can cast from a polymorphic virtual base class to a derived class or a sibling class
(§22.2.1). A static_cast (§11.5.2) does not examine the object it casts from, so it cannot:
void g(Radio& r)
{
Receiver∗ prec = &r; // Receiver is an ordinary base of Radio
Radio∗ pr = static_cast<Radio∗>(prec); // OK, unchecked
pr = dynamic_cast<Radio∗>(prec); // OK, run-time checked
Storable∗ ps = &r; // Storable is a virtual base of Radio
pr = static_cast<Radio∗>(ps); //error : cannot cast from virtual base
pr = dynamic_cast<Radio∗>(ps); // OK, run-time checked
}


The compiler cannot assume anything about the memory pointed to by a void∗. This implies
that dynamic_cast – which must look into an object to determine its type – cannot cast from a void∗.
For that, a static_cast is needed.


Both dynamic_cast and static_cast respect const and access controls.

From a design perspective, dynamic_cast (§22.2.1) can be seen as a mechanism for asking an object
if it provides a given interface.

// check on visitor pattern in youtube
It is best to avoid calling virtual functions during construction and destruction.

Charpter 22

It is not possible to overload a class template name, so if a class template is declared in a scope,
no other entity can be declared there with the same name. For example:
template<typename T>
class String { /* ... */ };
class String { /* ... */ }; // error : double definition


A concept is not (yet) a language construct in
C++; it is a notion that we can use to reason about requirements on template arguments, use in
comments, and sometimes support with our own code (§24.3).

Types generated from a single template by different template arguments are different types. In
particular, generated types from related arguments are not automatically related. For example,
assume that a Circle is a kind of Shape:
Shape∗ p {new Circle(p,100)}; //Circle* converts to Shape*
vector<Shape>∗ q {new vector<Circle>{}}; // error : no vector<Circle>* to vector<Shape>* conversion
vector<Shape> vs {vector<Circle>{}}; // error : no vector<Circle> to vector<Shape> conversion
vector<Shape∗> vs {vector<Circle∗>{}}; //


Non-static data members can be const, but unfortunately not constexpr.
a member function of a template can be virtual or not. However, a virtual member function
cannot also be a member function template

template<typename T>
class Vector {
public:
using value_type = T;
using iterator = Vector_iter<T>; // Vector_iter is defined elsewhere
// ...
};
The template argument name, T, is only accessible to the template itself, so for other code to refer
to the element type, we must provide an alias.

A static member need only be defined if it is used (§iso.3.2, §iso.9.4.2, §16.2.12). For example:
template<typename T>
struct X {
static int a;
static int b;
};
int∗ p = &X<int>::a;
If this is all the mention of X<int> in a program, we will get a ‘‘not defined’’ error for X<int>::a, but
not for X<int>::b.


The out-of-class definition of a member enumeration is only allowed for an enumeration for which
we know the underlying type (§8.4).
As usual, the enumerators of a non-class enum are placed in the scope of the enumeration; that
is, for a member enumeration, the enumerators are in the scope of its class.


A member template cannot be virtual. For example:
class Shape {
// ...
template<typename T>
virtual bool intersect(const T&) const =0; // error : vir tual template
};


My rule of thumb is ‘‘A void nested types in templates
unless they genuinely rely on every template parameter.’’ This is a special case of the general rule
to avoid unnecessary dependencies in code.


template<typename T> class Matrix;
template<typename T>
class Vector {
T v[4];
public:
friend Vector operator∗<>(const Matrix<T>&, const Vector&);
// ...
};
template<typename T>
class Matrix {
Vector<T> v[4];
public:
friend Vector<T> operator∗<>(const Matrix&, const Vector<T>&);
// ...
};
The <> after the name of the friend function is needed to make clear that the friend is a template
function. Without the <>, a non-template function would be assumed. The multiplication operator
can then be defined to access data from Vector and Matrix directly:


A compiler can deduce a type template argument, T or TT, and a non-type template argument, I,
from a template function argument with a type composed of the following constructs
(§iso.14.8.2.1):
T const T volatile T
T∗ T& T[constant_expression]
type[I] class_template_name<T> class_template_name<I>
TT<T> T<I> T<>
T type::∗ T T::∗ type T::∗
T (∗)(args) type(T::∗)(args) T(type::∗)(args)
type (type::∗)(args_TI) T (T::∗)(args_TI) type(T::∗)(args_TI)
T (type::∗)(args_TI) type (∗)(args_TI)
Here, args_TI is a parameter list from which a T or an I can be determined by recursive application
of these rules, and args is a parameter list that does not allow deduction. If not all parameters can
be deduced in this way, a call is ambiguous.

Lvalues and rvalues are distinguished by template argument deduction: an lvalue of type X is
deduced as an X& and an rvalue as X.

"Here" is an rvalue, so forward(string&&) is called, passing along an rvalue, so that Xref(int,string&&)
is called to move from the string holding "Here".
The more interesting (subtle) case is:
auto p2 = make_unique<Xref<string>>(9,x);
Here, x is an lvalue, so forward(string&) is called, passing along an lvalue: forward()’s T is deduced to
string& so that the return value becomes string& &&, which means string& (§7.7.3). Thus,
Xref(int,string&) is called for the lvalue x, so that x is copied.


[1] Find the set of function template specializations (§23.2.2) that will take part in overload
resolution. Do this by considering each function template and deciding which template
arguments, if any, would be used if no other function templates or functions of the same
name were in scope. For the call sqrt(z), this makes sqrt<double>(complex<double>) and
sqrt<complex<double>>(complex<double>) candidates. See also §23.5.3.2.
[2] If two function templates can be called and one is more specialized than the other
(§25.3.3), consider only the most specialized template function in the following steps.
For the call sqrt(z), this means that sqrt<double>(complex<double>) is preferred over
sqrt<complex<double>>(complex<double>): any call that matches sqrt<T>(complex<T>) also
matches sqrt<T>(T).
[3] Do overload resolution for this set of functions, plus any ordinary functions, as for ordinary
functions (§12.3). If a function template’s argument has been determined by template
argument deduction (§23.5.2), that argument cannot also have promotions, standard
conversions, or user-defined conversions applied. For sqrt(2), sqrt<int>(int) is an exact
match, so it is preferred over sqrt(double).
[4] If a function and a specialization are equally good matches, the function is preferred.
Consequently, sqrt(double) is preferred over sqrt<double>(double) for sqrt(2.0).
[5] If no match is found, the call is an error. If we end up with two or more equally good
matches, the call is ambiguous and is an error.


Templates offer:
• The ability to pass types (as well as values and templates) as arguments without loss of
information. This implies excellent opportunities for inlining, of which current implementations
take great advantage.
• Delayed type checking (done at instantiation time). This implies opportunities to weave
together information from different contexts.
• The ability to pass constant values as arguments. This implies the ability to do compile-time
computation.
In other words, templates provide a powerful mechanism for compile-time computation and type
manipulation that can lead to very compact and efficient code. Remember that types (classes) can
contain both code and values.


charpter 24

[1] First, we look at our (initial) implementation and determine which properties (operations,
functions, member types, etc.) it uses from its parameter types (and the meaning of those
operations). The resulting list is the minimal requirements for that particular template
implementation.
[2] Next, we look at plausible alternative template implementations and list their requirements
on their template arguments. Doing so, we may decide that we should place more
or stricter requirements on the template arguments to allow for alternative implementations.
Alternatively, we might decide to prefer an implementation that makes fewer
and/or simpler requirements.
[3] Finally, we look at the resulting list (or lists) of required properties and compare it to lists
of requirements (concepts) that we have used for other templates. We try to find simple,
preferably common, concepts that can express what would otherwise be many long lists
of requirements. The aim here is to make our design benefit from general work on classification.
The resulting concepts are easier to give meaningful names and easier to
remember. They should also maximize the degree of interoperability of templates and
types by limiting variations in concepts to what is essential.

Charpter 25

To be used as a template argument, a type must be in scope and accessible.



An argument for a template value parameter can be (§iso.14.3.2):
• An integral constant expression (§10.4)
• A pointer or a reference to an object or a function with external linkage (§15.2)
• A nonoverloaded pointer to member (§20.6)
• A null pointer (§7.2.2)


A pointer used as a template argument must be of the form &of, where of is the name of an object or
a function, or of the form f, where f is the name of a function. A pointer to member must be of the
form &X::of, where of is the name of a member. In particular, a string literal is not acceptable as a
template argument

This restriction, like the one against floating-point template value arguments, exists to simplify
implementation of separately compiled translation units. It is best to think of template value arguments
as a mechanism for passing integers and pointers to functions. Resist the temptation to try
something more clever

An integer template argument must be a constant.


Consequently, a sorting criterion is not built into the container type or into the element type. In
principle, the notion of sorting criteria for a map could be represented as:
[1] A template value argument (e.g., a pointer to a comparison function)
[2] A template type argument to the map template determining the type of a comparison
object

Passing the comparison operations as a function object has significant benefits compared to passing
pointers to functions:
• A simple class member function defined in-class is trivial to inline, whereas inlining a call
through a pointer to function requires exceptional attention from a compiler.
• A function object with no data members can be passed with no run-time cost.
• Sev eral operations can be passed as a single object with no additional run-time cost.


If we had only one use of a comparison criterion in our program, it might make sense to use a
lambda to express the function object version a bit more tersely:
map<string,int,Cmp> c3 {[](const string& x, const string& y) const { return x<y; }}; // error
Unfortunately, that doesn’t work because there is no conversion of a lambda to a function object
type. We could name the lambda and then use that name:
auto cmp = [](const string& x, const string& y) const { return x<y; }
map<string,int,decltype(cmp)> c4 {cmp};


Only class templates can be template arguments.
The common case in which a template needs only a container or two is often better handled by
passing the container types (§31.5.1). For example:
template<typename C, typename C2>
class Xrefd2 {
C mems;
C2 refs;
// ...
};
Xrefd2<vector<Entry>,set<Entry∗>> x;


Page 689  730 start Charter 25
stock on the move till page 98


